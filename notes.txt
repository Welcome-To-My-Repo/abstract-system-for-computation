type system supports both extensional and intensional definitions of a type.
they are treated as mutually dependent descriptors.
Thus an extensional type can be defined as the explicit list of all the other types which share its qualities and an intensional type can be defined as the explicit list of the qualities which other types must possess.
The distinction betwen the two approaches to definition is that extensional definitions of type can be reasoned about simply by referring to the list defined for that type whereas intensional types rely more on inference about whether the appropriate qualities are exhibited.

ASC compiles to an arch-independent assembly.
the assembly has an infinite number of general purpose registers.
it also has a set number of special registers.
	- Program Counter
	- Base Pointer
	- Zero
Data types correspond to the data types in ASC.
Operations are 
	- Add
	- Subtract
	- Multiply
	- Quotient
	- Remainder

ASC syntax is created by patterns.
There are a few notations which are determined using characters rather than symbols. 
This allows these notations to be represented with any format the programmer may chose.
These character notations are:
	-function declaration
	-function definition
	-sequence definition
	-sequence access
	-sequence introspection
	-type declaration
	-type assertion
	-type introspection
	-module definition
	-module access
	-conditional evaluation

The function declaration specifies the name of the function and the names of each parameter.
Function declarations may optionally specify a generic definition of the function.
A function definition specifies the types allowed for each parameter and a definition which is applied when parameters of those types are given to the function.

How do to sequence definition with just types and no names?

{1 2 3} `a sequence of constants`
{long long short} `a sequence with fields named "long", "long", "short"`
Sequence(long long short) `a sequence with fields typed long, long, and short`
Sequence(100) `a sequence with 100 fields`
Should a sequence be allowed with no default values? No.

Characters which are used directly in syntax.
().:;"'`[]{}&#^@

Default symbols...
( ) [ ] { } . .. : " ' ` & # ## @ ^ ? ??

Function declaration:
name (p1 p2 p...) = expr(p1 p2 p...)
name (p1 p2 p...) = expr(p1)
name (p1 p2 p...) = p3 {expr1(p1) expr2(p...) p3 = expr3(p2)}
name (p1 p2 p...) = p3 r... {p3 = p1 r... = p...}
name (p1 = x p2 = y p... = z) = p3 {p3 = expr()}
name (`...`) = p3 begin yeild name `returns in the immediate context`
name (`...`) = p3 begin end name `returns to call site`

Function call 
name()

Pointer syntax just overloads the "@" character.
@ of any type except location generates a location.
@ of a location dereferences it.
actually makes things safer.
if you have nested structures then you don't need pointers to pointers because
you would use data type declarations to assert a specific memory layout.

Types are viewed as non-distinct geometric formations.
The size, shape, positioning, and dimensions of a form are not known.
Two things are considered: what (non-descript) features may be present on a form, and what features are shared between two forms.
Types can be defined as a unique form, a combination of multiple forms, a difference of forms, or a superposition of multiple forms.
A combination exhibits all the features of a collection of forms as a unique formation.
A difference exhibits all the features present in one form that are not shared with another.
A superposition is not a unique form, but instead may simultaneously exhibit any one form in a collection of existing forms.
A sequence is then an ordered collection of forms.
A function is a transformation from one collection of forms to another.
The types of functions and sequences are also represented as forms.

AND /\
OR \/
NOT ~

notation prefix is semicolon ;


Continuation design:
To implement full continuations, they must have 6 capabilities...
1.) Asymmetric; be able to move control back to the point where the continuation was called.
2.) Stackful; act like a regular function with its own context and stack.
3.) Delimited; have a finite definition that doesn't contain the entire program.
4.) Multi-prompt; ability to be nested and recursive.
5.) Reentrant; dynamically capture the program state at a given point as a callable continuation.
6.) Cloneable; ability to duplicate any continuation object.

Continuations as functions:
	- Dynamic extent enables 1, 2, 3, and 4
	- Function ends by returning to call site enables 1
	- Function ends by continuing to the next lexical control point enables 2
	- Declare a continuation as an immediate function enables 5
	- Treating continuations as first-class functions enables 6

Continuations only need dynamic extent and a delimited capture.
A delimited capture works like call/cc but only includes the lexical extent of its context.
The exclamation point (!) captures its context.

Functions in ASC can be defined using one single expression or two separate expressions.

A program is executed by evaluation.
Evaluation involves the process of applying functions and reducing them to their return parameters.
Through the process of evaluation, the program may change state and behavior.
Each time a program changes state, a mode is implicitly created.
A mode represents everything that is known about the program at the point where the mode is created.
Modes can be nested and have similar extent to scope, however modes are also affected by assignment and conditional evaluation as these both are ways where a program may change its own state.

How to do quoted macros and stuff like the backquote in common lisp?
A good example is forcing heap allocated variables to work like regular variables...
; . (x:Symbol) = ?? & (x) == Box Heap-Lookup(x) x

ASC doesn't really require an IR because it's already at C's level.
What it needs is a few operators for binary crap with registers.

Top-down semantic description sucks, but is helpful for describing the interaction of types with a dynamic program.

Evaluation schemes for Notation parameters.
Normal evaluation is implicit so captures expressions are evaluated before the notation is applied.
Deferred evaluation forces a captured expression to be preserved until after to notation is applied.
A parameter that has been deferred can be evaluated during the notation application by writing it by itself inside parentheses.

``Ex``

T = [value]
U = [value]
V = [value]

; . (x:T) = f(x) `normal`
; . (,x:U) = f(x) `deferred`
; . (,x:V) = f((x)) `deferred forced eval`

j:T = value
j `=> f(value), j is evaluated before f is called`

k:U = value n:U = value
(k + n):U `=> f(k + n), expression is evaluated after f is called`

h(x) = x:V
l:V = value
h(l) `=> f(value), l is forced to be evaluated before f is called`

if two types are alike? what does that represent?

Zero is a superposition of all zero values in the number tower.

0 = [0 +0 0.0]

Notation for conditionals:
Single conditional "if"... ? cond exp
conditional "if-else"... ?? cond exp exp
condition uses the following comparisions and boolean operators

Generic Comparison:
Equal		=

Numerical Comparisons:
Greater than 	>
less than 	<

Logical Connectives:
and 		/\
or		\/
not		~

Type Comparisons:
supertype	>
subtype		<
alike		-

Should default operators be special characters or should they follow normal symbol rules?

Brackets are special characters because they are used as boundaries.
The vertical bar is also a special character because it's used with modules.
But what about operators such as pointers?


What about foreign function calls and ABI mis-matches?
honestly just make a foreign function call convention which matches the convention of one of GCC, MSCV, or Clang.
should ASC compile directly to assembly? Yes, because it employs special context manipulation which isn't possible in any other language.

what is type specification?

Ex:
	T = [x y z]
	var:T(x) `what does this mean?`


say you want a symbol with parentheses in it.
the symbol quotation operator drops special notations and just does visible vs. spaces

`(parens)

now to use the symbol as a symbol, evaluate it with parentheses

( `(parens) )

actually parentheses randomly unquoting symbols is dangerous. 
i need an unquote operator.

symbol quote:	`
symbol unquote: `` 
`(symbol)



primitive operators:

symbol quotation
symbol unquote

entity location
access location

entity storage requirements
entity cardinality

entity index subscript
entity member access

type composition is just a sequence.
In normal type systems, dependent types combine types and values, but in 
pure type systems, types and values are types. 
Take the classic List dependent type example. There's an abstract list type 
where the definition depends on a length value.
In a pure type system, the list type is a type, and the length value is also a 
type.
List types then become type tuples.
The constraint that the List is the "interface" of the type and the length is 
part of the type information becomes a meta-logical decision.
Now list types are simply a normal list type with a length just like how they're
defined using records in other languages.

So now if unit types are
	U = [U]
and type superpositions are
	S = [t t t]

then type compositions are
	C = [k.l.m]
where
	C..1 == k
	C..2 == l
	C..3 == m
and 
	&{x:p y:q z:r} == [p.q.r]



dependent types means that there's some value attached to type information which can be erased.
if types are completely tied to structs as they exist during a program, type information can't be erased.
how to attach random types to stuff which don't affect the interface?
how to erase types?

Ex:
asserting that a list is longer without necessarily keeping track of the length.

SLTN:
Dependent types exist because of the explicit notion of type erasure.
The types which depend on terms are discarded once the terms are proven sound.
Pure type systems don't need this because everything is types. Terms are just 
unit types.

Type erasure reduces to proving equality between two programs.
For instance, functions across a dependent list type can be proven using a 
dependent list length annotation. But the same action can be achieved in a pure
type system by proving the equality of functions over a list with an explicit 
length and functions over a list without an explicit length.
Basically any compilation level optimization becomes a form of type erasure.

Now I just need to prove equivalence between things.

1 + 1 = 2

f([Nat > 1]) = 0


================================================================================
SUPER IMPORTANT
================================================================================

support term rewriting instead of f expression style macros?

What's the difference?

macros involve invoking expressions which are matched and replaced.

term rewriting involves substituting portions of the syntax tree and requires 
proof of equivalence.

a simple example is constant folding. how would I explicitly define constant 
folding.

1 + 1 = 2
Constant + Constant = (Constant + Constant)
; (x:Constant `+ y:Constant) = x + y `enforces all constant addition is performed at compilation` 

Say a function f of a certain expression is rewritable as a separate function application
; (`f `( x:k `) ) = g(x)

what if I want to say that a function f can be replaced with a function g
; (`f `( ,x `) ) = g(x)
; ('f ( ,x )') = g(x)

; ; 'f ( ,x )' = g(x)

; 'a' = b `rejected because terms are not equal`

SKIP ALL THAT, JUST MAKE EXPRESSIONS COMPARABLE

Comparing constant expressions is simple

1 + 1 = 2

(. (x = 1) = x + 1) = 2

What about variables?
x = 1 `x can only equal one here because the most accurate type is the unit type, 1`
`x being typed as a Natural means that it can be equal to any unit which is a subtype of the natural numbers`
x:Natural = 1
x:Natural = 2

Register + 1 = 2 = 1 + Register

Natural + Natural = Natural + Natural
x:Natural + y:Natural = y:Natural + x:Natural

equality rules:
	- the expressions on both sides must evaluate to the same thing or else 
	  a semantic error occurs.
