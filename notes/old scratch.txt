no comments, annotations instead.
you can ask the compiler to look up documentation about bound variables.
annotation operator is ` and it takes a string after it.
so 
	x = 1 
	x ` "bound to 1"



ASC is a tool, just like any other.
More specifically, ASC is like an angle grinder. 
Angle grinders are used in almost every craft because they are powerful, precise, and highly versatile.
The only stipulation is that you have to know how to use one properly.
For example, the object you're grinding must be held in a stable position and there's only a few safe ways to hold the angle grinder.
If you use one the right way, angle grinders come with many safety features so that you will never be surprised or hurt.
Unfortunately most craftspeople don't bother to learn proper safety techniques before they use an angle grinder.
This often results in cases of permanent maiming or even death.
When you use ASC properly and safely, you'll create practical and beautiful things.
Make sure to learn what proper use and safety mean for ASC or else you and others could get hurt.



the concept of This (%).
"This" refers to the immediate context.
The context is the collection of bindings.
For example:
in a block
	x : 1 , This x = 1 . 

in a collection
	{x : 1 .  This x} = {x : 1 .  1}



Implicit Qualification:
Implicit quantification involves applying an operation to a type, implying that
the operation is performed for all values of that type, producing a new type 
that represents all the values possibly returned from that type.



How do I describe a self describing system?
Corecursion.
I say that a system "x" is given the properties "y", which are defined by a system "x".
I describe ASC as a program which interprets ASC, written in ASC.
Then the definition is a matter of what external information is required to comprehend the program.
What external information is required?
... Default expression syntax
... Default expression semantics
... Requirements of a correct program
... Requirements of the default module
... The manner in which evaluation can be reconciled with the real environment.
Oddly enough type rules are not external information, but are part of the interpreter.



How does execution happen?
You submit a program definition to the environment.
This program can affect other programs by modifying the context.
A program depends on the context.



What does the environment provide?
... Storage
... Placement

What does evaluation provide?
... entity duration
... structured context



ASC environment functions:
... Compute (effectful)
... Compile (discrete)
... Describe (discrete)
... Disassemble (discrete)
... Display (discrete)
... Export (discrete)
... Import (effectful)
... Inspect (discrete)
... Link (effectful)
... Obfuscate (discrete)



How to introduce a new expression?
An expression is a collection of types and symbols provided as the surface for the context.

	(Expression ".") : Expression. | e -> (e_0)
	(Expression "\n") : Expression. | e -> (e_0)
	("(" Expression ")") : Expression. | e -> (e_1)

You want to be explicit that you're making an expression, not just another surface.
This also makes the context more easily searchable by type because you can simply do
	% / (Expression | *) to get the collection of all the expressions.

How does select by type work?
It compares the possible values of the selecting type and if an element is value-equivalent to any of them, then it is yielded.



Expressions are just a specially interpreted collection.
Except that everything can be a specially interpreted collection and I turn into a lisp. blech!
Expressions are their own datatype.
Quoting expressions and stuff is hard to represent as a collection.
You start overloading collection semantics with special cases for computation.
A quoted expression represents a whole program rather than just a collection.
What's the notation for a collection then?
The semicolon,
	; "a‚Äù T 'T ;
That makes a new expression.
What operations are available for an expession?
- quote
- unquote
- destructure
But aren't expressions the same as collections?
What if I want to write an expression that builds an expression that writes itself?
That would be a collection.
You can just take an expression to be a collection though.
	('f 'x):Expression
	{'f 'x}:Expression
	; 'f 'x ;
these are all the same, but the last line allows you to avoid writing out the type when its use is obvious to the user.
In all instances, an expression is a collection of syntax entities.
	Expression: (( 2 '- 1) '+ 1)



Need semantics for interpreting numerical and string constants.
There's textual data which acts as a constructor.
All symbols are strings.
Numerical symbols are constant values.
The value expressed by a number is exact.
Semantics for how a number is interpreted should be at the program level, not a compiler thing.
The rest of the syntax is the same.
A numerical symbol is a constant.
A string is not a constant.



How to clobber stuff.
What is a binding?
A binding is a program that yields some entity held in the context.
There's two ways, accessing a collection or using an expression.
Binding is
	x = 1
resulting in
	; 'x ; | %\(# %) <- 1
in plain english, binding an unbound symbol first clobbers the value being bound into the context. Then it exposes it as a surface using an expression containing the symbol being bound.



Compute has a type which is dependent on the value the expression produces.
If I say 
	(n -> n + 1) (compute "string")
I get a type error because compute doesn't produce a numerical value.



Should there be error effects?
Say
	f = x -> x + 1. ,
	f (1 2)
should application use an error handling thing?
No.
What about
	x : [n = Value, ? n > 30 n _],
	x = random.



what happens when I run a program?
I have an expression
	1 + 1
this is Read as 
	;1 '+ 1;
which can be passed to the context to recieve a result.



Is there a way to cause a dynamic error during computation? 
Yes, but it's hard to achieve.
	c = {% ``x},
	% <- c .
This is a type error



How to tell the difference between an expression and a collection?
	{ {'a 'b 'c} '/ 'a}
Because you need to have a quote and unquote.
	quote ({'a 'b 'c} / 'a)



How do you treat a symbol as data?
The single quote
	'symbol
How do you treat an expression as data?
Single quote with parentheses
	'(expression)
How do you evaluate a quoted symbol?
	('symbol)
How do you evaluate a quoted expression?
	('(expression))
How do you destructure a quoted expression?
'(1 + 1)\0 = 1
'(1 + 1)\1 = '+
'(1 + 1)\2 = 1
Why are some symbols quoted but other symbols are not?
It depends on the expression form.
In the case of addition, it's 
	; Value '+ Value ;
quotation works by using the apostrophe to quote an expression
	' 1 + 1
	' n -> n + 1
You quote a symbol as
	` x
or
	` x.
to avoid ambiguity

The expression constructor is two semicolons.
It allows shorthand notation for various forms of repetition.
	; Value 'x "%" [A B] * ;



How does evaluation work?
The initial context has a number of built-in functions which facilitate the default expression semantics.
A function entity has an implementation dependent representation.
All the default types depend on the implementation and environment.
What is my evaluation model?
Compute gets an expression, it passes the expression to the context surface.
It the expression is defined, then the context returns some other expression to compute.
This process repeats until compute passes a default expression and recieves an entity.
What about functions?
Functions are an assumed type and application is a default expression.
Applying a function is managed by the environment.
Functions contain expressions though.
Functions are equivalent to binding a symbol and computing a quoted expression.



Evaluation model is this, for every function call and surface interaction, a new context is created.
In each context is
	{ External-Context : Collection
	  Current-Expression : Expression
	  Other-Stuff : * }
Once Compute completes the current expression, it replaces the context with the result in the external context.
If you replace the context with a value, it short circuits the computation.
If you replace the current expression with another expression, it short circuits the computation, but you keep the same context.



How is an expression evaluated?
	"First bind an expression as a surface",
	% + {{'add Value 'to Value}| e -> e\1 + e\3},
	"Then you use the expression",
	add 1 to 2.
Now read reads in the expression.
You get 
	{'add 1 'to 2}
Compute passes it to the context surface
	(e\Expression %)
It recieves another expression and calls Compute on it.
What computes compute?
The environment.
The environment provides the basic functions from outside the scope of the language even though the language can inspect its own environment.



Collections use result polymorphism.
	1 {1 | 'a  1 | 'b} : 'b = 'b

Can functions be defined for multiple things?
Yes.
	f : x -> x + 1,
	f : x -> x / T,
	f {n:T} = T,
	f 1 = 2.



What happens when you clobber the context?
How does it affect control?
Because the expression being evaluated is inside the context.
	n = 1,
	n <- n + 1,
	% <- n + 1,
	"code beyond here is not evalutated",
	n <- n + 1.
Why?



What is the context model?
In a context, you have
- The expression being evaluated
- The external context
- Bindings
How is this structured?
External context is first.
Then the expression being evaluated.
Functions are deferred computation.



Compute takes an experession and passes it to the context.
The context returns another expression.
What does that look like?


	Compute = e -> 
	 e:Collection,

What is a surface? 
It's a way to access information inside a collection.
When are surface interactions evaluated?
During execution.
	x : 1,
	c : {1 | 1},
	c x = 1

all expressions are reduced to 
- function application
	f x
- evaluation
	(x)
	(x y z)
- Conditional Evaluation
	? p q r
- sequence
	f x, g x
- interaction
	x c
- constant
	1
	'1
	"1"
	{1 1}
	[1 1]
- Default Operation
	Algebra
	Boolean logic
	Comparison
	Subscript
	Destructure
	Type of
	Size of
	Reference
	Dereferece

These operations are built into the environment and computing them produces implementation dependent behavior



What is my model for expressions?
An individual expression is a collection of constructors, punctuation, and nested expressions.
A quoted expression allows you to read in an expression as an unevaluated expression structure.
So 
	`1 + 1 = (1 '+ 1) = {1 '+ 1}
What about
	`1 + 2 - 3 = ((1 '+ 2) '- 3) = {{1 '+ 2} '- 3}
How do you tell the difference between an expression and a collection?
You quote punctuation differently than you quote a symbol.
Punctuation and types determine an expression.
Lisp only needs one quotation notation because the function is always the first in the list.
I can't because the function may have any form such as juxtaposition of two types of elements.
So how do I quote an expression?
The backquote.



How do I treat an expression as data?
An expression is a collection of symbols and other expressions.
How do you create an expression?
	e : Expression
	e\0 : 1
	e\1 : '+
	e\2 : 1
	e = `1 + 1
	e = (1 '+ 1)
If I say
	x : 1
then
	Compute ('x) = 1



VERY IMPORTANT PROPERTY
	c <- {x = y  y = x}
	c\0 = c\1



recursive expression possible?
	% + {'a} | 'b,
	% + {'b} | 'a,
	'a



how does string syntax work?
You say that there's some stuff in between two quotation marks.
Inside quotations, the backslash character has special syntax.
What you need is a character-by-character parsing algorithm.
I need two things, the type of a stream and the ability to express something that repeats.
A character type is any expression that's evaluated to produce a character.
Read is different. 
It has a collection of characters.
Can't be reader macros because you can jump in and out of interpreting characters.
Read takes a string and turns it into a data structure.
Does read bind things?
No.



IMPORTANT-----------------------------------------------------------------------
	? e : T 
	  T : e
	  ^e \= T
"if computing 'e' yeilds a value of type 'T', then it follows that it's possible to compute 'T' in such a way as to get 'e'.



How to make a list?
You have to create a new context where you grab everything.
Then you have to set a new context where you build the list structure.
I need a way to set a new context for a specific expression.
Say you can have any "c" between "a" and "b".
The expression returns the number of "c".
This requires two things, an intermediary value holding the number of "c".
And an order in which the "c"'s occur.
Order is determined by the order of the stream.
The "c"'s are in a sequence already.
So the solution is to allow new context to be set around a specific expression.
Given the expression form 
	{'a 'b ... 'c}
There's two expressions,
	{'a e 'c} 
and
	{'b ['b _]}


Expressions for a context are stored in a collection.
	% 'Expressions
They are distinct from the rest of the collections by location.



what are maps? 
Aren't they just closures?
Can't you do that with syntax?
Not really.
	d : {'a | 'b  'c | {1}}
	'a 'c d = 'b
You can't do this with closures.
There's a mechanism for propagating across contexts.



ASC is an inductive pure type system.
The ":" and "[ .. ]" operators allow the construction of new types which are just terms on a higher stratification.

So then the ASC type system consists of sorts or entities "A"
And has the rules,
	(A_0,A_0)				.... Base
	(A_n,A_n),(A_n,A_m),(A_m,A_n),(A_m,A_m)	.... Inductive
so what does this look like in ASC?



Symbols are any sequence of alphabetic characters with no white space.
Values are symbols prefixed with a single quote.
Types are one or more unique values.
Types can occur as values in other types.



not worrying about the inductive proof.



what is the nature of maps and collection surfaces?
theres a collection.
it has some elements.
you can access those elements by destructuring the collection.
you can also provide more complex polymorphic interactions.
what do i mean by interaction?
is this a function?


IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ASC is not based on the Lambda Calculus, It's based on objects.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
what do I mean by that?
A function is actually an abstraction in my language.
The most primitive abstraction for "doing something" in my language is 
passing an event to a collection.
The primitive ops are
- collection constructor	{ ... }
- clobber			_ <- _
- bind				_ | _
- sequence			... , ...
- this				%
- deconstruct			_ \ _
- cardinality			# _
- value				' _

is this all I need?
Yes
So how to do recursion?
By an event passing it to itself.
Self reference.
{* | % *}




Semantics are based on interactions.
Rather than message passing, one object is introduced to another with a reaction defined.



If I have a collection
	c : {'a 'a 'a}
and I compute
	c / 'a
i get 
	{'a 'a 'a}
but how do i get one of the elements when they're the same type?
By casting. 
If I have the same collection and I cast it to a nested collection
	c ~ {'a {}} / 'a = 'a
This is a terrible kludge for just indexing.
However the index of a collection is unique to each collection.
What if you can index based on anything?



Get rid of function notation an functions alltogether.
You don't need them.
Instead of passing functions, you pass around collections.
If you want to make a function, all you do is
{* -> p}
You can't really shadow anything though which makes things hard.
But on the other hand, context and binding in the context are first-class structures.
How would this look?
It would look terrible.



What is binding?
Binding is when you use a symbol as an expression.
	(Expression : {'x}) | 'value
Binding is another form of macro.



What are my semantics for computation.
Compute is given a program representation as some "p" where
	(p)
and P is composed of one or more nested expressions.



What order should computation reduce expressions?
It finds the first expression that has no nested expressions.
It uses that expression to interact with the context.
The context produces more data or another expression.



What if I use period like a lambda abstraction?
	x . x + x
How do I talk about functions in a generic way?
when i talk about the type of a function, i don't talk about the symbol used as a parameter.




how do pointers work?
they arent typed.

x . x + x



	x <- 1
	y <- x @
	z <- y @
How do pointers work?
Are they typed?
Yes.



So what's my fucking notation now???

Assignment: _ ; _
Binding: _ : _
Parameterization: _ . _
Application: _ _ 
Interaction: _ _

How does juxtaposition work?
Can you juxtapose in either direction?

	f : Function,
	c : Collection,
	x c f,
	x f c,
	f x c,
	f c x,
	c x f,
	c f x

so you can actually juxtapose in any direction.
What about currying?
	
	g : (Function *): Function,
	g c f x x = g(c f x)(x),
	g c f x c = g((c (f x))c)
what is the algorithm here for application?
you have a sequence of juxtaposed terms.
how are they reduced?
You have an something that can be applied and something that can't, then there's several cases
- a a	the first is applied on the second
- a c	the first is applied on the second
- c a	the second is applied on the first
- c c	none are applied, this is two separate expressions.
So aren't infix operators just
{* | x . {* | y . op(x y)}}



I don't know if I like my syntax.
The symbols and names for things aren't that great.
How do I do better?

Constructors are obvious
Types:		[ ... ]
Collections:	{ ... }
Compute:	( ... )

Type Binding is the colon	:
Clobber is the semicolon	;
They're both forms of binding.

I also need shortcuts to refer to
Type of Types:		[]
Type of Collections:	{}
Type of Functions:	()
Type of Expressions:	()
Type of Symbols:	Symbol
Type of Anything:	*
Type of Nothing:	_
Is there any point where I would need an empty version of any of these?
No, in most cases where I'm talking about empty constructors, I'm talking about the generalized types of those.

What about destructuring collections?
You can select by type or by position.
Select by type:		_ / _
Select by index:	_ \ _
Might be a complaint that these operators aren't clear.
What else can be used for selecting?
Underscore, colon, semicolon, period...
I think the forward and backward slash are fine for this.

Should the function constructor be an arrow or a dot?
x . x + x
x -> x + x
An arrow. It's more clear what's going on.
If that's the constructor, how do I write a function type?
It's different than a function constructor because I'm not talking about which symbols I'm binding as parameters.
It would be more like 
"Something applied to something computes to something"
Is a function the same as an expression?
Yes actually.
So then a function of A to B would be 
	(Function A : B)



What's minimal ASC?
no types
everything is a Value
You have arithmetic
the ability to clobber
equality comparison
no variable names, everything is from the context.



Fixed context elements:
% / Expression
% / 


How to identify what is an expression in the context and what is a normal binding?
Make an expression type.
({'b} | 1) : Expression



A property where
(x -> x : 1) *  = 1



What happens when I clobber a surface?
% ; % + 1 | 1, % 1 ; 2
You can't actually clobber a surface.
You can replace it with another surface.



If you need a context then you need to forcibly enter a new context.
How do you do that?

%\#% <- Expression : 
	{'a} | % <- 	{
			% 
			count : Value 
			(Expression : {'b} | count <- count + 1)
			(Expression : {'c} | % <- %)
      			}



What's the minimal syntax?
	{ ... }
	( ... )
	_ <- _
	%
	_ = _
	_ /= _
	_ < _
	_ > _
	@ _
	^ _



how does construction work?
You claim a portion of storage not less than the storage requirements of the constructed object.
The storage portion is treated as a place and is given a unique place value.



how are collections made?
Can elements in a collection be in separate locations?
Yes. 
The collection is an object and the objects "in" the collection are separate.
Does this mean that the entities in the collection can be in non-adjacent locations?
Yes.
How to enforce something has an adjacent location?
What information does a collection actually contain then?
The location of each of its elements.
Is there any case where type information should be dynamically included?
Type information is stored separately from the program.
So what happens if I query the type of something?
	^ x
The type information is constant.
What is type information?
The program that results in the type.
So if 
	x : T
then
	^ x = T
you're not actually querying the type of the binding.
You're querying the type of the entity that the binding evaluates to.
So 
	^ [a b c] = Type
	^ (a : [a b c]) = [a b c]
	^ 1 : [1] = [1]
How are types held in a context?
Say that you make a new type. 
How is it incorporated with other types?



The type system is not affected by context?
Or is it?
If I have 
	a = Type, b = Type, c = Type,
	x : [a b] = b,
	y : [a b c] = b,
	^ x, ^ y
the type needs to be bound in the context.
if the type is released from a context then you can't use it.
Also how about enums?
	T = [a:Type b:Type c:Type]
what does an unbound symbol in a type mean?
That it's a value of that type.



how does each expression handle unbound symbols?
1	(a)
2	[a]
3	{a}
4	a = 'e
5	a : t

1: returns a semantic error that "a" is not computable
2: binds 'a as a value to the type
3: returns a semantic error that "a" is not computable
4: binds "a" to 'e
5: binds "a" to t
Are these computed?
Yes, compute dispatches a program which decides how to bind the unbound symbols.



a collection is a separate entity from its elements.
a collection and each of its elements each have unique locations.
what about data that's adjacent?
use a value type for that.
you have default values and you can create new compound values from that.



what about operator precedence in arithmetic?
	Sum : Number
	Product : Number
	Exponent : Number
	% <- % + {}



There's a collision between how a function is constructed and how it's typed.
A function constructor takes a parameter name as a symbol, but it does not allow for an input type to be specified with the parameter.
The purpose of a function is twofold. 
It creates a symbolic substitution of a variable with an input parameter.
It encloses an expression in a context which is evaluated later.
Thus a function is structurally typed according to the input-output pair, and it exists as a syntactic form.
Using arrow notation, how should a function be given a parameter and a type?
        f : T -> t
        f = x -> y
So the function constructor has the form
        {Symbol '-> Expression}
When should the function constructor have the form
        {Expression '-> Expression}
that's simple, it would be
        f : (T) -> t
        f = x -> y
Because the type of () always yields an expression.



Data description.
The environment assumes the presence of two capabilities:
The ability to hold data while a transformation is being applied.
The ability to store data while it is not being held.
A minimum of two data formats are required, a format for transformations and a 
format for storage.
The storage format is called a Byte.
The transformation format is called a Word.



What are my terms?
A collection can include a surface as an element.
A surface maps some entity to another entity, the reaction.
A program may interact with a Collection by providing it with an entity matching the type of entity in the surface.
The collection will then produce the reaction entity.



How do I create expressions?
By backtick and parens.
`(1 '+ 1)
It's the same as asserting that you're creating an expression
(1 '+ 1):Expression
So how would you do a macro?
	% <- % + `{'o T} | t, o T
=
	`(`(`(%) '<- `(% '+ `(`({'o T}:Expression) '| `(t))) ', `('o T))
=
	`(
		`(
			`(%)
			'<-
			`(
				%
				'+
				`(
					`(
						{'o T} : Expression
					)
					'|
					`(t)
				)
			)
		)
		',
		`(
			'o
			T
		)
	)
Here's the problem, this is a nested expression which introduces a macro to the context and then uses that macro.
How is this possible?
Read determines the innermost expression, then computes it.
So this means that Read and Compute must be interleaved.
Or this means that Compute is the same function as Read.




A hard limit of the universe is that if I have a compound expression
	e1, e2
where the well-formedness of "e2" depends on computing "e1",
then I cannot verify that "e2" is well-formed without first computing "e1".



If my language is dynamically typed, can I stil check expressions?
Say I have two functions,
	f : (a) -> b
	g : (d) -> c
and I combine them,
	(g f a)
I get a type error when the reader determines 
	(f a)
without evaluating the function.



the type of an expression is known ahead of time because it's an interaction and interactions are typed just like functions are.



what if a function includes new syntax?
	f = x -> (% <- % + {'a x} | n -> n\1, a 1)



how are types taken into account?



evaluation model is stratified
you have a compound expression, 
	e1, e2
and reading e2 depends on evaluating e1, so then you would compute e1 explicitly
	compute e1, e2



so I have a context, %
it's a collection containing the grammar, the expression being computed, and any context-bounded data.
	% = {g = {}, e, d_0, d_1, d_2, ..., d_n}
I can change the grammar, the expression being evaluated, or any of the data.
I want specific behavior, when I write
	% <- e
I want the context to be replaced entirely with one evaluating "e".
when I write
	% <- {}
I want the entire context to be replaced with the new collection.
what form does the context have?
the address of the external context.
so I'm replacing part of the context.
what does the context contain?
- the address of the external context
- the collection of grammars
- the expression being evaluated
- the collection of data
so there's four things.
how do I expression these four things?
just specific indicies in %?
or do I use names?
I should use a combination of names and types

%/Expression yields the current expression
%/% yields the external context
%/Collection yields all the bindings
So there's a triple of a context, an expression structure, and a collection of bindings.



what higher order operators should I use with collections?
i have a filter operation already
	c / t
I want an operation that does something for each element.
that's just iteration.
but is it built in?
no just iterate or provide a macro.



so how do I iterate?



What's the notation for creating an expression.
It's just ( ... )
What if I want to quote a constructor?
("{" 'a 'b 'c "})
That's how you quote a constructor.



Say I have two collections
A : Collection, B : Collection
how would I make them contain each other?
A = {B}, B = {A}
This works because the collection is a separate structure than the entities. 
Rather than an infinite nested chain, it's a cycle.



collections are just vectors of pointers.
so you can easily filter append and delete from them.
How do you do that?
addition and subtraction
can you add one at a time?
no you can add multiple
{a} + {b} = {a b}
{a b} - {a} = {b}
{a} + {{b}} = {a {b}}



how do I interleave computation?
Like with my "dependent" contexts thing.
how do I say `e1` before reading `e2`?
	(e1), e2
	Compute e1, e2
how do I quote an expression?
	x <- ` 1 + 1
just the backquote
that makes an unevaluated expression
then you can eval it a bunch of times
	x <- ` 1 + 1, (x) + (x)
or you can do a tagbody
	n = 10, (loop <- ` ?(n > 0) n <- n - 1, (loop) n)



So how are Read and Compute interleaved?
Every sub-expression is treated as an individual program.
Contexts are built up as each program is computed.
Lets take a very confusing program.


	(x <- ` %/Collection <- %/Collection + {")"} | 1)
this modifies the context so that the closing paren evaluates to the number 1 rather than bounding an expression.
but it's quoted so it's not evaluated right away.
It's evaluated after it's bound.
so then the expression is equivalent to 
	(x) 1
So it depends on how the expression is read in and when computation is dispatched on a program representation.
What I have right now is that Read identifies an expression form and 



What is the language hidden in the language?
Function application.
Surface interactions.
Flexible left-or-right juxtaposition.
Currying.
Collections.
Types.
The context model.
Addition and Subtraction on everything.



Do I need to allow reader macros?
Shouldn't there be some kind of reserved characters?
Sure. 
If you want crazy synax, make your own parser.
You can always hand strings to stuff.
So I should be able to reserve some characters and still allow for macros and stuff.
Or I should allow for anything.
I think I can allow for anything.




How to do contexts?
Say I have syntax
	%/Collection <- {{'a t} | T . {'b} | t .}
now how do I do contexts for the expression "a b"
The reader reads in "a" and determines the expression {'a t}
Another expression follows "a" so it constructs
	(a (%))
and reads some more until it determines {'b}
then it has
	(a (b))
which turns into 
	(a t)
which turns into
	(T)
so now i've learned two things,
having a complete program model requires you to compute the program.
A compiled program computes until it reaches a program model with only default syntax.



I do want my code to be self modifying or at least reflective which should work fine since i have homoiconicity.
I also want to do it without parentheses.
in scheme you have 
	(define x 1)
	(lambda (x) x)
and 
	(define (f x) x)
in ASC you have
	x : 1
	x -> x
and 
	f = x -> x
which are structured as 
	('x ': 1)
	('x '-> 'x)
and
	('f '= ('x '-> 'x))

I want a specific constructor for an expression so that it can be typed differently than a collection.
What does that look like?
Just type the thing as an expression.
It doesn't help with nested expressions though.
So multiple things in parens are expressions
Multiple things in curly brackets are collections

` {'a 'b 'c} '- 'a
({'a 'b 'c} '- 'a)
Does this mean complexity, or I just have two separate ways to create the same thing?
I just have two separate ways.


This language is getting complex.
Or is it?



How can I quote an expression that defines its own custom syntax?
I add delimiters in.
` (% <- % + ('a x) | e -> e\2, a 1)
But how does it get read in if I don't know the form of the expression.
Or what case would exist where I want to define new syntax in the middle of the program?



I have a constructor for functions which are just dealing with contexts.
I have a constructor for collections which reduce to sparse vectors.
I have a constructor for types which reduces to collections of unique values.
Therefore I should have a constructor for syntax.



The problem is that my programs are stringly typed. 
You need to read them and compute as you go.
That's slow and expensive, but highly expressive.
I want the structure to be explicit from the types rather than from punctuation.
What do I actually want from my syntax?
I want the ability to parse ANY grammar.
This means I need to have an unrestricted grammar.
In my langauge I have an expression which is a map and is treated as a production rule.
	('a b) | c



Maybe I'm overthinking.
Say I have some values,
	a : [], b : [], c : []
Make a grammar...
	% <- {('f a) | b . ('g b) | c}
Make an expression...
	g f a
But this is all one program
	a : [], b : [], c : [],
	% <- %+ {('f a) | b . ('g b) | c},
	g f a.



How can the context have the current computation if the current computation hasn't been read in yet?
How does this expression work?
	dotimes	= n -> e ->
	      (k <- ` ? n > 1 
	      		(e), n <- n - 1, % / Expression <- k
			(e))
Lisp-ified
	(bind dotimes (lambda n (lambda e 
		(clobber k (quote (if (greater n 1) 
			((eval e), (clobber n (- n 1)), (clobber (in this Expression) k))
			(eval e))))))
remove parens
	bind dotimes lambda n lambda e
		clobber k quote if greater n 1
			eval e, clobber n - n 1 clobber in this Expression k
			eval e
The structure is still almost clear since every word is either a function or a parameter.
My language has infix operators and all sorts of crap so it's harder.
Read "harder" as more ambiguous.



how does reading work?
Say I have an expression,
	"x + y"
and it's program model is
	(('x) '+ ('y))
It's computed as
	(compute(((compute ('x)) '+ (compute('y)))
How is read interleaved into this?
Not sure since Read has to determine the structure.
How to determine when Read should read more things?
Read has to go by expression.
Or the context does not contain expression bindings.
That doesn't make sense because you can bind tokens in a context.
There's the structural part. 
Every token is delimited by space.
Expressions have no set delimiter unless you're lisp and you use parentheses.
Expressions are not ambiguous though, you just need to infer the boundaries.




So the read function accepts a string describing a program model and produces the program model.
It determines an expression by matching symbols to declared patterns.
So how then do I make the switch between undelimited expressions and delimited expressions?
A sub-lisp.
Parens form collections without creating a new context.
One expression for each pair of parens.
Constructors and constants can skip parens.
I can also construct this by the expression quotation.
I get the structure automatically.
So then I can add parens as I want for visual clarity or to remove any possible ambiguity in application order.



What's my syntax then?
Constructors...
	Collection	{ ... }
	Type		[ ... ]
	Expression	( ... )
	Function	_ -> _
	Number		0123456789
	Byte		Byte
	Word		Value
	Composite	_ ; _

Expressions...
	Add		_ + _
	Sub		_ - _
	Mul		_ * _
	Div		_ / _
	Mod		_ | _
	And		_ /\ _
	Or		_ \/ _
	Not		  - _
	Less		_ < _
	Greater		_ > _
	Equal		_ = _
	Inequal		_ /= _
	Conditional	? _ _ _
	Application	_ _
	Interaction	_ _
	Type of		^ _
	Address of	@ _
	At address	@ _
	Size		## _
	Cardinality	# _
	Type Select	_ / _
	Index Select	_ \ _
	

Constants...
	This		&
	Any		*
	Nul		_




Aren't interaction and application the same thing??
Yeah.
A function is constructed as
	{Symbol, Expression}
When you apply the function, it's
	* {Symbol, Expression, * | p -> %/Symbol <- p, (%/Expression)}



How to quote an expression that defines new syntax?
Parentheses.
How to bind an expression?
Can I just create an expression and then bind it?
	('if p:Boolean 'then m:Expression 'else n:Expression) = ? p (m) (n)
Or do I have to do
	% <- % + ('if Boolean 'then Expression 'else Expression) | 
		e -> ? e\1 (e\3) (e\5)
In lisp, you can do something like macrolet where you define a macro which is used in a temporary context.
In my langauge, you can define new syntax for any context.
The problem is how you can quote an expression that modifies the part of the context that Read uses.
The answer is to just use lisp forms. 
If you want to quote an expression, you simply build the program model.
You don't need quoting because you just go straight to making the data structure.



How should I set the expression in the context.
It should be an interaction.
	& x , "sets the expression to whatever 'x' is"
Here's the problem though, what happens if a function needs to return an unevaluated expression?
If you try to say that the final result is an expression, then that expression just gets computed.
	"exit a context", & <- d
	"set a new current expression", & e
	"set a new binding", & <- & + b



A surface shouldn't need a function to work.
There should be a parameterization method that is not a function.
Parameterization is syntactic though.
Binding of a symbol is deferred until computation.
What about currying though.
How to add two numbers by currying collections?
	add = {Number | { Number | x + y}}
So can it just be that the first symbol is bound to the argument?
Is there any problem to that?
Nope, the algorithm for resolving symbols can just keep a list of everything that needs to be bound and then bind them as it discovers parameters.



I don't like that the program model isn't static.
I can't have a program model that must be partially evaluated to make sense.
The structure of it must be in the syntax.
With lisp, that's parentheses.
I have no structured syntax.
You have to determine subexpressions from punctuation and type information.



The decision is this: a program is the composition of some computations which are repeated in the same way for each time the program is run. 
Some of these computations are only required to be run once for all possible repetitions of the program. Maybe to configure the initial state of the program, or to abbreviate repetition in the program model. 
How do I decide which computations are run exactly once for a program?
I would place the results of these computations as constant values.
How do I make constant values? I create types.
Compare
	x = 1
	y : 1
here "x" is bound every time the program is run, but "y" is only bound once.
How about complex programs?
	z : [f x]
here "z" is bound to the result of some sub-program which is computed only once ever to produce the final program.
Is this the same issue as syntax or a separate issue?
Possibly the same.
It's a tiny bit insane that a program must be read and executed all at the same time.
It's more than a tiny bit insane that reading one part of the program is dependent on computing a previous part of the program.
I also can't switch between this and static checking of a program.
Or can I?
Technically the program I write can be one that builds a program model, which is checked as it goes, representing the final program.
So if I want a complete statically checked program then I build a program that checks everything before it completes.
So then this means I start with a completely dynamic program and slowly build up static checking.



Should an assembler and other stuff be part of the implementation or part of the standard library?
It should be part of the implementation.
The assembler should also take some kind of minimum subset.
An "untyped" langauge where everything is just Words and Bytes.
What does that language include?
	Collections 	{}
	Clobber		_ <- _
	Equality	=
	


A whole program is read in and a complete model is constructed before it's computed.
This means that a program cannot define new syntax and then use it.
This sucks and isn't necessary.
It's better to have a static verifyer as part of the library.
Use meta to its fullest.
Enforce portions of a program which are verified as part of compilation.
This is super duper meta.
How does new syntax fit into this?
Think of the progression of 
"I am going to"
"Im going to"
"Im gonna"
"Imma"
Abbreviation for commonly repeated things in a domain is useful.
And 20% of the time you can't just abbreviate using built in function notation.
Some languages like smalltalk or forth are lose enough where it doesn't matter.
Here's a compromise, Read and Compute use a copy of the syntax that's defined when they were called.
That copy is internal to their state and can't be modified.
Because variable binding and expression binding are different mechanisms.
Variable binding is taking a symbol constant and interacting with the context
	x
	& 'x
Expression binding is algorithmically replacing part of the program model with a different part.
Variable binding is resolved as a context access.
Expression binding requires the compute function to fullfill.



What types of errors can result from not writing a correct program?
-	"program is mal-formed"
-	"contradicting bindings"
-	"no matching definition"
- 	"ambiguous expression"


How is an expression typed?
An expression is either a constructor, in which case it's replaced with data, 
	('k) | "data"
or it has some "holes" where sub-expressions are placed
	('k t) | 'e -> e\1
A hole is signified by a type.
Punctuation is signified by a value.
An expression returns a type which is either some data or another expression.
Is the type of something that returns an expression, an expression?
Not when Read is verifying the program model.
Expressions are assumed to be computed so the type is never an Expression unless
you are computing something that constructs a program model.
So then the type of an expression is what results from computing it.
How do you determine the type of an expression?
By observing the types of the sub-expressions.
Sometimes the type of a computed expression may depend on the type of the sub-expression.



The type of an expression is the type of the element produced when it is computed.
In the case of an expression comprised of nested expressions, the type produced 
by computation may depend on the result of computing one or more of the sub-expressions.



Should I provide functionality as C or as bytecode?
If I provide it as bytecode then you can port it anywhere.
I'm thinking about it wrong though.
All I'm coding in C is the read, compile, and display functions.
Anything else is compiled straight to assembly.
There's a lot of type stuff which I would like to be statically checked before computation.
But there's also a bunch of dynamic stuff which is useful to have.
What's a compromise between each.
Expressions are computed as they are encountered.



Binding can associate symbols with entities or entire expressions with entities.
Binding requires unification.
The goal of Unification is to find for each unbound variable a type with the least number of values.
I would like to bind both variables and expressions.
I would bind a variable by 
	x = 1
assuming x is unbound.
I would bind an expression by
	('if Expression 'then Expression 'else Expression) = ? Expression (Expression) (Expression)
	('loop [('for Number) ('while Boolean)] Expression) = 


What does labelling an expression look like?
	do : Number -> Function -> * =
	'n -> 'f -> (
		( l : `	? n > 1 
			(f), n <- n - 1, (l) 
			(f) )
as a one-liner
	do : Number -> Function -> * = 
	'n -> 'f -> (l : ` ? n > 1 (f), n <- n - 1, (l) (f))

Is this the same as goto?
No.
Goto is if you set the context to an expression.

	do : Number -> FUnction -> Number =
	'n -> 'f -> 
			& l : ` ? 
				n > 1 
				(f), 'n <- n - 1, (& l) 
				(& f)

Both arrows produce special behavior with symbol constants.
The function constructor takes a symbol constant to create a parameterized expression.
The clobber constructor will create or update a binding when given a symbol constant.




How to bind expressions?
An expression is a collection subtype consisting of symbol constants, strings, values, and types.
It's formed using parentheses as
	('a b "c")
But how to bind an expression to some semantics?
The easiest way is to use a function.
	('a b "c") -> ...
But then how do you destructure the parts of the expression?
Do you use a static placeholder?
That prevents currying.
You need a way to bind something to parameterize the expression.
Originally, I combined surface and function notations so that an expression was defined as 
	('a b "c") | 'd -> ...
where the expression was bound to the symbol used as the parameter.



What does the string constructor look like?
	("\"") | _ -> 'str <- {},
		& 'r <- `
			(Read : Char) {
				"\"" | & <- str .
				"\\" | 'str <- str + (Read : Char) .
				Character | 'c -> 'str <- str + c .
			}, 
			(& r) .


What's the deal with commas and periods?
If I'm defining a function, I want
	f = 'x -> a, b, c .
But if I'm defining a function inside a block, I want
	block = (
		f = 'x -> a, b . ,
		f k
	)
a period and then a comma works.
	a , b . , c
is the same as 
	((a , b) , c)

What if I only used parentheses?
How would that look?
Would that even be useful?
I am so tempted to give up and use parentheses instead of inferring the structure.



So I have a number type which can represent complex numbers.
The types are as follows...
	Natural : [], Negative : [], Fraction : [], Irrational : [], Imaginary : [], 
	Integer : [Natural Negative],
	Rational : [Integer Fraction],
	Real : [Rational Irrational],
	Complex : [Real Imaginary],
	Number : 
		[
			Natural
			Negative
			Fraction
			Irrational
			Imaginary
			Integer
			Rational
			Real
			Complex
		]
The first row of value types are default types where the resources required to represent those types are different.
This is not a good idea because it's not extensible. 
The hierarchy stops at the complex numbers and does not admit extensions to any of the types.
Better to use primitives.
At most I should provide Integers and anything beyond that should compose from some kind of ordinal numerical abstractions.
So I start with
	Natural : [], Negative : [], Integer : [Natural Negative],
	Number : [Natural Negative Integer].
This should work because addition, subtraction, multiplication, and division across these whole numbers works properly.
Anything beyond this should require type abstractions rather than being default.



What if I used parentheses instead?
How would it look?
	
	"Bubble Sort",
	BS : List -> List = 
		'l ->
			'n <- 1, 
			('s <- `
				? (l \ n) > l \ (n - 1)
					swap (l n n - 1),
					(s) .
					'n <- n + 1 ,
					(s) .)

vs a delimited expression form

	[ "Bubble sort,
	[[BS : [List -> List]] = 
		['l -> [
			['n <- 1] ,
			[compute ['s <- [? [[l \ n] < [l \ [n - 1]]]
				[[swap [l n [n - 1]]] ,	
				['n <- 0]
				[compute s]]
				[['n <- [n + 1] ,
				[compute s]]]]]]]

The one without delimited expressions is objectively better. 
You can read it easier. 
There's no huge clump of parens at the end of the top level expression.
Parens are used to delimite sub-expressions where necessary.
If you can use regex, then you don't need parens.
Regex is not unrestricted though because you can set context.
That's fine, you can set context in ASC too.



How is stuff stored?
I need to decide because compound data is part of the language.
All the more complex constructs must have a cannonical representation as bytes.
The trick is that all this stuff can have any format it wants because the 
default operations for them ase already supplied.



How is stuff represented in memory.
Each thing has a representation as a compound data type.
Data is one of 
Byte, Word, Reference.

Symbol is a sequence of bytes.
Collection is sequence of References.
Function is a pair of a Symbol and an Expression.
Number is a sequence of bytes.
What is a type?
A collection of unique values.
What about a quantified type?
	"A normal type is ", [1 2 3],
	"but a quantified type is ", [x : T, f x]
	"where the values may not be finite."

So the reader has to infer the structure of the program model from punctuation.
This is easier than you would think because the punctuation usually makes sense.
Also the read direction is always from left to right.
Nope, I'd rather do a Lisp.
The point is that grammar can be whatever you want for any given expression because 
individual expressions are always delimited.
There are things that count as expression though.
() [] {} "" '
Nobody's going to care that much about the syntax as long as the language does cool stuff.
What's my expression delimiter?
<> () [] {}?
Parens are a traditional delimiter, but my language is not a lisp. 
It can be emulated as a lisp, but it's not.
Take a simple program...
	((f : (T -> T)) = ((x) -> x))
	<<f : <T -> T>> = <<x> -> x>>
	[[f : [T -> T]] = [[x] -> x]]
	{{f : {T -> T}} = {{x} -> x}}
Definitely parentheses are the way to go.



So if I'm using parentheses, what's my syntax?
I can take full advantage of structural cues.

Expression 	("(" * ")")
Function	[(* '-> *) (Expression '-> *)]
Collection 	("{" * "}")
Type		("[" * "]")
Sequence	(* "," *)
Binding		(Symbol Expression)
Interaction	(* *)
Addition	(* '+ *)
Subtraction	(* '- *)
Multiplication 	(* '* *)
Division	(* '/ *)
Remainder	(* '// *)



What about a math expression? 
How would that be described?
I would like to create a math expression where you can put any number of numbers and arithmetic operators in one expression.
I also need to honor operator precedence. 
Parens are always evaluated first because they form sub-expressions.
1. exponentiation/root
2. multiplication/division
3. addition/subtraction
I would like expressions to look something like this:
	(1 + 3 - 2 * 5 / 3)
rather than
	(1 + (3 - ((2 * 5) / 3)))
which is still better than common lisp's
	(+ 1 (- 3 (/ (* 2 5) 3)))

What is my syntax?

Constructors:
- Collection		("{" * "}")
- Type			("[" * "]")
- Function		(* '-> *)
- String		("\"" * "\"")
- Expression		("(" * ")")
- Data			(* '; *)

Operations:
- Addition		(Number '+ Number)
- Subtraction		(Number '- Number)
- Multiplication	(Number 'X Number)
- Quotient		(Number '/ Number)
- Remainder		(Number '// Number)
- Logical And		(Boolean '/\ Boolean)
- Logical Or		(Boolean '\/ Boolean)
- Logical Not		('- Boolean)
- Destructure by Type	(Collection '/ *)
- Destructure by Index	(Collection '\ Natural)
- Reference		("@" Location)

Comparison:
- Equal			(* '= *)
- Inequal		(* '/= *)
- Less			(* '< *)
- Less or Equal		(* '<= *)
- Greater		(* '> *)
- Greater or Equal	(* '=> *)

Computational Forms:
- Interaction		[(Collection *) (* Collection)]		
- Conditional		('? Boolean Expression Expression)
- Sequence		(Expression "," Expression)

Reflection:
- Size			('## *)
- Type			('^ *)
- Cardinality		('# Collection)
- Location		("@" *)
- Bind			(Symbol *)
- Clobber		(Symbol '<- *)
- Coerce		(Type '~ *)

Special Constants:
- Number		[+-]?[0-9]*[\.\/]?[0-9]*?\^?[0-9]*?
			A symbol consisting of all numerical digits, 
			optionally prefixed with a plus or minus,
			optionally interceded by a decimal dot or fraction,
			optionally suffixed by an exponent
- Any			"*"
- Nul			"_"
- This			"&"



How to parameterize surfaces?
The surface has access to its own context but it should also have access to the 
interacting entity.

{ (T | 'x (x + 1))}


What is a dependent type vs. a refinement type.
A refinement type is some type which is a subset of another type such that
	((T : Type), ((#(refine T)) < (# T)))
A dependent type is some type which is produced from a computation and can be any size.



How to bind expressions?
I can do
	(x = (1 + 1))
which unifies x with something
but what about
	((x y) = (3 4))
or something more clear
	(('if Boolean 'then Expression 'else Expression) = (? Boolean Expression Expression))
Here it understands that it's seeing an expression on one end and can unify the types.
What about a weird function definition?
	(((f : Function) 'x) = ('x -> x))
It appears as 
	((Function 'x) = Function)
Then you can unify that 'f should be bound to the function and 'x is a parameter.
Unification is triggered by an unbound symbol.



Here's some insanity,

(((x ('+)),
 (y (1)),
 (z (1)),
 (y x z)) = 2)



Let's make an un-typeable expression by creating a new expression
	` (& <- (& + (('a *) | 'T)))
Now let's make an untypeable function
	('x -> ((('n *) = 'Type), (n)))
So how can you type a function?
A function is untyped until you assert that it's typed.
If you don't provide any assertions to track, then you don't track any.
What about type errors?
That's a program failure.
So then you don't actually track the type of a function, you just say that
the definition of a a function is a sub-type of another function type,
(f : (t -> T))
(f : ('x -> (m x)))

So how then would I assert the type of an expression?
	((x : T), `(e))
What happens when I violate the assertion?
	(((x : T), ('x `((& <- (& + (('n) | P))), (n)))), (x))
The program will compute until "(n)" and then abort.
That kinda sucks.
That's what happens when you allow a program to mutate the context.
Also it's what happens when you allow a program to computationally define its own syntax.
So then you can chose between how early a computation can abort and how weird you want the syntax to be.
Compute is always (* -> *) unless more type information is provided.



When is an expression type-able?
An expression is type-able when the result of computing the expression depends 
on a typed expression.
If 
	((^ (Compute T)) = t)
then
	((^ (Compute ` T)) = t)

I'm addressing the wrong thing.
I can't talk about the type of an expression, I can only talk about the result of computing it.



There's a factor of separating definitions between programs.
In a program representation where all expressions are known, the reader can 
construct and check the structure of a program model.
However a program model may bind and use new expressions at any point.
This means that the result of computing a new expression is unknown until after 
the expression definition has been computed.
If you create all the expressions you are going to use in a program that's run
before the program which is checked, then you can know the type of all expressions.



Take for example
	(((Number . 'plus . Number) = (Number + Number)),
	 ((1 plus 1) : Number))
This type assertion cannot be enforced at read time because the type of the expression is now known.
However this can be changed by doing

	((Number . 'plus . Number) = (Number + Number))
	((1 plus 1) : Number)
This expression can be typed when the program is read because the expression has been previously defined.



I really really want to do static typing.
An expression type is 
	[(e : Expression), (? ((e) = T) e _)]
Where the result of computing an expression must yield some type.
Should each expression have a result type?
The result type is formed from the surface.
Expressions have types, but their result also has a type.
A bound expression actually appears as
	(e | T)
where computing the expression 'e results in some type 'T.



What about parsing?
Regular grammars are expressible by regular expressions, but I want full-on parsers.
How do I manage a set of parsers?
The grammar for ASC is pretty straightforward.
You have three kinds of braces, string delimiters, and a syntax for numbers.


How do I statically type this language?
Given you know the type of all the expressions, this is easy.
You can eagerly reject all models where types are known to mismatch.
Expressions which are typed as * are disregarded.



How does variable typing work?
Say I have
	1, (T = [A B C]),
	2, (x : T),
	3, (x : A)
How is this possible?
What is the actual value of x?
Well in line 2 the value of x is unknown but is something of a type T.
Type assertion is a computation constraint.
Is a type binding the same as a value binding?
Not really, it's a quantification.
	(x : T)
quantifies the values of x to the values of T.
I'm losing most of the static typing capabilities that i want from my language.
But i didnt want static typing, i wanted dependent typing.
Type information is manifest in that compute will not perform an operation if it knows type constraints will not be followed.
So how is type information tracked though?
Generally by 
	(n (e)), (? ((^ n) = T) n (& Type-Error))
All checks are dynamic.
But how is type information stored?
If I say
	(x : T)
then 'x cannot be replaced with a single value, but the possible values of 'x are constrained.
Is this simply binding x to T?
No because 'x must compute to a value of T, not T itself.
So binding then sets the supertype of the variable.
each variable now has to track multiple things.

What happens when I say
	(x : T), (x : A)
where
	((^ A) = T)
If you constrain a binding to a type which has no values, then the binding is to the type itself.
Thus for any non-type constructor,
	(x : c), (x = c)



Who keeps track of type constraints?
Does compute have additional context to manage type constraints?
What happens in this program?
	(('f : a -> b) ('x -> b)),
	(n : b), (f n)
'f cannot be applied to 'n because 'n is clearly the wrong type.
Here the types of both f and n are known before the application is computed.
But where are the types?
It's extra information which is accessed via reflection.
	(x : T) 
sets a type constraint.
	(^ x)
gets a type constraint.
such that
	((^ (x : T)) = T)



What about binding?
	(x *) 
binds x to the thing following it
	(x <- *)
removes the current binding and type constraints and creates a new binding
	(x : *)
constrains all future bindings such that they must be to values of the type.



so if a type constraint is violated, then compute aborts with an error.
there is no recovery or restart.
no debugger.
No I'd rather enter a debugger.
Say I encounter a type error in a malformed program.
Something like 
	(1 + "2")
what would be my options?
- change the sub-expression.
- abort the computation.



how to define a function like haskell?
	(((f : Function) x) = ('x -> x))



how do I define a recursive type in ASC?
In Haskell, it's something like,
	data List n = Node n | Node n (List n)
this describes a singly linked list.
In ASC this would be
	(List : [{*} {* List}])
A Tree structure would be
	(Tree : Type),
	(Leaf : {*}), 
	(Branch : {Tree Tree}),
	(Tree : [Leaf Branch])


How to deconstruct a collection?
Given
	(C = {1 "2" '3})
How do you deconstruct by index?
	((C / 0) = 1)
How do you deconstruct by type?
	((C \ Symbol) = '3)
What about simpler stuff without symbols?
Terser, structure-based syntax.
I need two syntaxes, destructuring based on index, and destructuring based on type.
I need two different notations because in the very common case that you try to deconstruct a collection of numbers, you need to be explicit that you're not destructuring by type and instead are destructuring by index.
Which will be more common though? 
Destructuring by type or by index?
Both will be equally common.
Take a large collection of small collections.
The large collection is destructured by index.
The small collection is destructured by type.



How do I do typing?
Types are collections of values.
A value is a subtype.
The type of a type is a supertype.
I can bind a symbol to a value.
Types are also values.
If I say
	('T [A B C])
Then
	('t T)
Binds 't to the type entity 'T.
But asserting the type of somethind is different.
	(e : T)
means that computing 'e must produce some value of 'T.
This is different than binding.
This is a constraint.
In the case of a variable
	(x : T)
'x is still unbound, but there is a finite set of entities which 'x may be bound to.

A type assertion is not the same as a type binding.
A type assertion can be applied to anything.
	((1 + 1) : Number)
However binding is not the same.
	((x : T) 4)



How to bind expressions?
Unification is the brute force shortcut
	((T  T 'a) = (f T T))
But it doesn't work the same as adding an expression surface to the context.
	(& <- (& + ((T T 'a) | 'e (f (e \ 0) (e \ 1)))))
Is expression binding the same as symbol binding?
How does it look as an AST?
	(1 + 1)
	{{1} '+ {1}}

	(f ('x -> x))
	{{'f} {{'x} '-> {'x}}}
So these two programs are semantically equivalent
	(f ('x -> x))
	(& <- (& + ({'f} | ('x -> x))))
Because symbols are taken as expressions.
How are types established though?
I can bind any program or sub-program to a type.
	((1 + 1) : Number)
	((x : T) t)
What does my variable binding form look like?
	` ([{Symbol}] *) | 
Should I provide refinement types?
No, because I already have them.
	(x : T)
means forall x, ((^ x) = T)
So how do I do type binding?
A type is a set of values.
A type can be a value.



How is type binding different than value binding?
A type binding constrains the result of a certain part of a program.
A value binding determines how an expression is rewritten.
	(x : T)
	(x = t)
	(x <- t)
A type can bind anything
	((1 + 1) : 2)
	('x -> ((x + 1) : 5))
How is a type binding to a variable different than a type binding to an expression?
	(1 + 1)
Will always have a definite value.
	(x : T)
Has an indefinite value, but has a definite set of possible values.
So then a binding can have multiple values?
What is my semantics for binding?
What if I do
	(x = y)
that means
	(x : y)
	(y : x)
how are type constraints enforced?
I set a constraint for an expression.
That expression must always evaluate to that type or a semantic error occurs.
Bindings can be given type constraints.
	('x <- e)
	(x : T)
	(x = e)
What about arbitrary refinement?
	('x <- 1),
	(x : Number),
	(x : Natural),
	(x : [1 2]),
	(x : 1)
These are all true.
What does this mean though?
It means that the compute function must enforce a semantic requirement.
Can you type an unbound expression?
	(x : T)
	(`(f x) : t)
So a value is known or it is indeterminant.
Thus implicit quantification is the case between a definite value and an indefinite value.
Can you quantify over an expression?
No.
Expressions are different than variables.
Variables are symbols that are replaced with data.
Expressions are an abstraction.
How do I separate variables and expressions?
Simple, a variable binding is
	(& <- (& + ('x | 1)))
Now 
	(x = 1)
Variable binding is different than expression binding because there's no pattern
matching involved.
You just look up the variables by
	(& x)
The tricky bit is determining if a symbol is a variable or a punctuation.



Expressions that admit unbound variables...
- type assertion
- unification
- clobber
Given 'x is unbound and 'y is bound, then the following expressions will bind
x
	(x <- y)
	(x = y)
	(x : y)
Should I drop all this and just use let binding?
How would a let form look?
Let is just a sequence form anyways.
I don't need let.
My sequence expression forms a context that's discarded afterwords anyways.



How do I do a map?
	((c = {1 2 3}),
 	 (f = ('x -> (x + 1)),
 	 (c' = (f ([c \ Natural]))),
	 (display c'))



Here's a weird thing: I want types to be computed before the rest of the program, but then I have to compute stuff dynamically.
I'm making the mistake that computation is still ordered.
Types are computed first, but it's not the same as lazy or out-of-order execution.
Computation should happen in the order that the program model represents.
	((x = 1), ([x]))



How do types work?
Given two types in a context,
	{(t <- [a b]) (T <- [t])}
What is the result of 
	(^ t)
is it 
	T
or
	*
By all rights, it should be T.
But how?
The type algorithm starts by getting the collection of all the types bound in the context.
Then it searches for any type that contains the value.
It gathers a collection of all types which contain the value.
It emits that collection.



What's the behavior of a typed expression if there's an unbound variable?
Does it unify?
For example, ((x + 1) : Number)
'x must be a number for the program to work.
What about ((x + 1) : 2)
Now 'x must have a specific value.
So with type constraints and equality, an unbound variable triggers a unification algorithm.
The unification algorithm will attempt to find the most general binding for each unbound variable.
What about a complex program with multiple unbound variables?
	(((z * 3) + (x - y)) : 10)
How would unification solve this?
It would encounter z which would trigger the unifier.
The unifier would begin guessing and encounter x.
It would begin guessing for two variables and encounter y.
Finally the unifier would begin guessing types for all three variables.



What are my storage semantics?
If you want to modify a constructed entity, you have two choices, you can either create a modified copy of the entity or clobber the portion of the entity which is being changed.
Given that every entity is serialized using Bytes, modifying an entity results in changing byte values in-place or copying the entire serialized entity and modifying bytes as they are copied.
The simplest rule is to completely eschew copying in every case.
Nothing is copied, everything is modified in-place.
Variables are treated as linear references to entities.
The clobber entity overwrites bindings to entities.
Take this example code
((x <- 1), "Here 'x is bound to 1",
 (y <- x), "y is bound to x",
 (y <- y + 1), (x = 2), "This is true",
 (x <- 1), ((x = 1) /\ (y = 1)), "This is true")
Is a constructor always guaranteed to claim new memory?
Yes.
Are numeric values constructors? Yes.
Clobber will overwrite the target value with a new value if the new value requires at most the same storage as the previous value.



How to do expressions?
(('if Boolean 'then Expression 'else Expression) | 'cond (? (cond / Boolean) (cond \ 3) (cond \ 5)))

Lets say I want to pipe a bunch of functions, f g h i j, would I have to do
(f (g (h (i (j x)))))
or could I just do
(f g h i j x)
or 
(f g h (x j i))
I should be able to do that last one?
But how?
What would that expression look like?
It would be an expression of any length where each argument is either a function or not a function.
Then you would walk across, pair-wise, applying functions to data.
There would be a program to interpret that.
Actually I'm not going to do that because that circumvents the entire point of being able to use parenthetical delimiters as a visual hint about the form of an expression.
Rather if I am able to write arbitrary length expressions, then why am I using parentheses in the first place.
If my language is good enough, people will come to use it.



What are the semantics for mutating elements of a collection?
You destructure the collection and then set a value.
Should I even have a collection?
Or should there be a different means of creating a data structure?
What about datalog as rules for constructing structured data?
That wouldn't work because datalog does not have a concept of meta-spatial relation.
You can't "group" things in datalog.

What would be a realistic tree implementation?

((tree : [branch leaf]),
 (branch : {data tree tree}),
 (leaf : {data})



What are the rules for shadowing?
Contexts are encapsulated by collections such that
((x = 1),{x = 2})
So say I bind a variable,
((x <- 1),
 {(x <- 2)})
In a new context, any binding is considered a fresh binding.
Such that
((x <- 1), [(x <- 2)], (x = 1)) is true



I want hard lexical scope so that I can reason about contexts as a data structure.
As such, an expression should only be able to search its own context which is different than a call stack
Lets make a closure which is hard.
((x <- 1), 
 (y <- {('v | 2) 
        {(z <- 3) 
	 {('n -> (x + ((y 'v) + (z + n)))) }}}),
 (((y / Collection) / Collection) 



So quoting an expression will create a copy of the context for that expression to be evaluated in.



A nested collection is a special case where two contexts must be combined.
There's two collections, one nested in the other such that 
{ {} }
where each collection has a context.
So we have an algorithm that begins with the outer context and constructs a new context.
How are contexts associated with the code?
Contexts are managed by the compute program.
However, the program being computed is capable of inspecting the context constructed by the compute program.



There should be an alternative way to do it with just parens.
So then you don't have to worry about everything.
A collection is formed by a bunch of things together
(1 2 3)
But that doesn't imply a new context so that's why the curly braces are important.
A type can also be
(1 2 3)
But that doesn't imply that each value must be unique from the rest so square braces are important.
Should I use squre braces for punctuation instead?
No.



What is my terminology for the | thing in collections?
You do functions by saying
{(Number | 'n (n + 1))}
you do pattern matching by 
{ (Case-1 | Match-1)
  (Case-2 | Match-2) }
you do object orientation by
{(data <- 1) (* | 'n (data <- n)) (_ | data)}
Wait, so aren't I just making functions then?
Because the handler has to close over the collection.
No this is different than functions.
You can make a singleton collection that does a function.
Not the same as a function, you can just make it look like one.
I can parameterize it.
It's not the same as doing a quoted thing.
How do you parameterize something?
Dumb question.
What is the differece between parameterizing a quote as a function and parameterizing a map?
I feel like there's some redundancy there.
Well functions are made by quoting a thing and storing it in a collection.
But when you send data to a collection, you need to provide a way for the collection to use it.
That's parameterization but also makes sense.
So then a function looks like
(* | 'x (x + 1))
It's a triple of some value which can be accepted, a symbol to bind the value to, and a program.
So how do I represent stuff as collections?
(1) = {1}
(1 , 1) = {1 ', 1}
{1 1} = {'{ 1 1 '} }
What's the difference then between 
'x
and 
x
because right now both of them show up as 
{'x}
and 
{'x}
Or do I just do type tags?
No that doesn't work.
So I quote an expression and I get
`x
which is 'x
But I'm forgetting type tags for determining which things are part of the program model and which things are data.
It's the same as assembly that way.
You just get a chunk of stuff and you have to pick it apart using rules.



What are my rules then?
How do I represent stuff in memory?
It all has a tag which is a word size.
So then it's easy to check which things are tagged as data and which things are tagged as programs.
Both the program and data is folded together because an interpreter program handles computing it.
Each entity has a type.
The type follows the entity around.
So everything is at least two words.
Except for compound data where you can specify a type and the data is packed.



How do you make an operation?
You define a new expression which has some symbols denoting the type of operation and some types which parameterize the operation.
How would you describe this then?
It's structural typing.
This means you can take advantage of the typing rules for structures, but applied to expressions.
For example, you can declare a logic expression.
((l <- ['/\ '\/ '-]), 
 [(c : Collection), 
  (? (((c / *) = l) \/ ((c /  *) = Boolean))
   c
   _ )
 ])



So what happens when you quantify?
Say that I do 
(f : (T -> t)),
(f T)
What do I get out?
I get t.



How to check that something is of a type?
(? (t / v)
Because types are collections of unique values, you can use collection operations on types.
The semantics are slightly different since the values in a type must be unique.



How to bind a symbol?
(x <- 1)
is semantically equivalent to 
(& <- (& + ('x | 1)))
Which means if an expression is
(& <- (& + ( 
 ('sum Number Number) 
 | 'e 
 ((e \ 0) + (e \ 2))) )
)



What should be the syntax for defining a new expression?
Variables appear in the context as 
('x | 1)
Expressions appear as
( {'add Number Number} | 'e ((e \ 1) + (e \ 2)))
So how do I describe an expression then?
You have a Form with some elements.
You either have default semantics for the form or you destructure the form into an expanded program.
So what I want is an insert operation.
Or an append operation?
I shouldn't provide an insertion operation.

(C <- {'a 'b 'c}),
(C' <- C + 'd)



So the syntax for binding a variable is (x <- 1)
What's the syntax for binding an expression?
A function.
You get the expression as a parameter. 
It has data in it.
You deconstruct the expression and perform ops on the elements of the expression.
Which is exactly the map notation
(n | 's m)
So I add an expression as
(& <- (& + ({'identity *} | 'i (i \ 2))))


What's my algebra for each thing?

Numbers
addition	{Number '+ Number}
subtraction	{Number '- Number}
Multiplication	{Number '* Number}
Division	{Number '/ Number}
Remainder	{Number '// Number}

Collections
union		{Collection '+ Collection}
filter		{Collection '/ *}
complement	{Collection '- Collection}

Types
supertype	{Type '+ Type}
subtype		{Type '- Type}
refinement	{Type '/ Type}



Drop maps/surfaces/all that crap.
You have a lambda, (t -> T)
The thing before the arrow is a type.
The thing after is the definition.
You can parameterize by adding a second thing before the arrow.
That's the parameter (* id -> id)
If a lambda is an element in a collection, that lambda can be invoked by applying the collection to the appropriate type.
({(t -> T)} t) = T
Do I add a type annotation?
so that (x -> (x + 1)) is typed as (x : Number -> (x + 1))
Or do I write (Number x -> (x + 1))
I like saying that the parameter is second.
Because this makes case matching so easy.

So I have only one syntax for functions and maps.
(T -> e)
(T p -> e)
I don't like that you can't specify the parameter.
Or I'm thinking about it the wrong way.
My language does respect types, so it's nice if you put the type in the function you're using.
If there's an actual case where you're applying a function that work for literally everything, then you still want to be explicit that this function is for everything.
(* id -> id)
You can type a function also by doing
(T t -> (t : T))



How to do expressions?
Desugared way is to do
(& <- (& + {({'id *} e -> (e \ 1))}))
So I want an operation which adds arbitrary things to the context.
(f <- ...)
this binds a map to the context ('f -> ...)
I want something that binds an expression to the context but with parameterization.
({'add Number Number} e -> ((e \ 1) + (e \ 2)))
So how to add this to the context?
Append.
You append by doing
(C <- (C + d))
So is there any reason to force an in-place append?
No because you don't actually want to go adding expressions willy-nilly.




Types are checked. 
I want to provide a way to check types using arbitrary programs.
Say that I want a collection where the first element is always type T.
(type <- [(c : Collection), (? ((^(c \ 0)) = T) c _)])
So then I can say that
(x : type)
And enforce that the type of the first element of x will always be T.



Is there a way to statically type things with macros?
Kinda?
So for every expression, () you must determine a type coming in and a type coming out.
How do you determine the type coming out of an expression where it might define its own expression.
Assuming I had a compiler that was capable of statically checking a program model.
How would I construct a model where the only way to check a type is to compute the program?

`(& <- (& / Expression `()))


Do I want a regular language where everything must be described in its own grammmar or do I want a language which is extensible?
I would like one that's extensible.
How to bind expressions in the context then?
I need a define thing except where there's multiple parameters.
How do I do that?
{'a ('x -> )}


Language is getting overengineered and hard to talk about.
Context is kinda useless since quotations close over everything.
Well maybe not.
What does this return
((x <- 0),
 (& <- (& / ('x -> *) ('x -> 1))),
 (x))
I set a context and then modify it.
Closures is not the same as a fixed context.
I can still take an expression and evaluate it.
Is that how I implement dynamic binding?
Don't I still have dynamic scope?
Because 
{(x <- 1) 
 {(x <- 2)} 
 {{(x = 2)}}}
The innermost is true.
So how is an expression evaluated.
Is each expression evaluated in its own context?
Some of the default expressions do not form their own context.
How to quote an expression without forming its own context?
The quote operation automatically captures the bindings.
What if I have a massive structure?
Then you use indirection so that the massive structure isn't copied with the function.
What about if I do something like,
((f <- (massive-file 10000000000)),
 (g <- (* x -> (x + 1))))
Which returns the function.
A naive implementation captures the entire function.
What about a quote that confuses something.
(e <- `(& <- (& + ({'a ('n -> *)} -> (f (a 'n))))), (a 1))
Here the quote would scan through and try to close over 'a even though its syntax, because it doesn't know it's syntax yet.
So I have a small sub-language.
Algebra over some primitive data structures.
Most of this is all easy.
The problem is being able to add expressions arbitrarily.
This means that anything after the expression definition requires the preceding stuff to be computed.
How to deal with this mechanism?
Ex: 




Let notation rather than variable binding?
I kinda already have it simply because I do
(x <- 1), ...
in order to bind stuff.
Could it be more clear though?
(let ((x 1)) ...)
Or does it even need to be?
What about expressions though?
Variable binding is a primitive.
Expression binding should be as well.
Should I express it as a mapping?
Yes.
But how to bind it?
Or you only have variable binding and lambdas?
No that doesn't work.
You have pattern matching over collections.



Should the context be first class?
It combines a number of things and "just use the context" could become an anti-pattern.



What is my langauge?
I have data, collections, functions, types.
Data is a format for holding information.
It has a size and a location.
You can combine multiple data formats to form data of any size at a location.
Collections are groups of data.
Collections are a form of data themselves.
The data in a collection is separate from the collection itself.
Functions in a collection can be used as an interface to the collection.
Functions can be parameterized or uninterpreted.
Types are unions of values.
Compared to just a value, a type represents the occurrance of multiple values.



First class contexts are based or cringe?
Based.
This means that code is disassociated from bindings.
Bindings are still static, but dependent on the context.
Does quoting an expression capture bindings? No.
Does creating a function capture the bindings? Yes.
How far can you nest contexts?
(_ -> (x <- 1), 
 (_ -> (y <- 1),
  (_ -> (z <- 1))))




how should new expressions be constructed?
Normal binding form is 
(x <- *)
Expression binding form is
(x '+ y <- (add x y))
((x : t) 'o (y : T) <- (op x y))
or is it
({(x : t) 'o (y : T)} <- (op x y))
Or should I specify some other way?
What about adding destructuring names?
It's the same as adding maps.
Here's what conditional evaluation would look like in my langauge.
({'if ('b -> Boolean) 'then ('a -> Expression) ('b -> Expression)} e -> (? (e 'b) ((e 'a)) ((e 'b)))
This also lets you do variadic arguments.



currying looks like
(Number x -> (Number y -> (x + y)))



How should I do expressions and contexts?
An expression is a kind of function.
And you want it visible to the context same as a variable binding.
Should there be some expressions which are declarative or top-level? NO.
Everything returns.
Variable bindings return the things they're bound to.
Expressions are different though.
An expression returns a function.
Weird.
So how would you do it?
You're not talking about a variable binding.
You don't want to return anything from an expression either.
So you would define expressions in a context.
How do you store stuff in a context?
There's variable binding which is stateful
(x <- *)
should there also be a define which is not stateful?
(define *)
is semantically equivalent to
(& <- (& + *))
should it be the word "define"?
Or should you be explicit?
(& <- (& + *)) I think it should be explicit.




How should I deal with the context?
The context by itself has the following interface
{(* x -> (& <- (& + x)))}



Without context what happens?
Crap. Contexts are necessary.
What about handlers?
Works off how the context is formed.

Start with a program.
(1 + (3 - 2))
read as
{1 '+ {3 '- 2}}
compute first expression
{{1 '+ {3 '- 2}} _}
resolve nested expression
{{1 '+ {{3 '- 2} _}} _}
Contexts interleave the expression.
Evaluate the nested expression
{{1 '+ 1} _}
resolve outer expression
2
What semantics are these?
There's a context which forms around a program being computed.
When the program is finished (reduced to a value), the context is replaced with the value.
In the case of nested programs, the context is formed around the node.



You can close over macro definitions the same as bindings.
Expressions are separate from contexts.
Functions close over contexts.
Collections close over contexts.



Expressions are defined at the global level.
How to import expression definitions?
Where are expressions stored?
In the context?
Is the global context separate from the normal context?
No.



There should be a declare form that just adds stuff to the context.
The form that appends stuff to the context is just an arrow to nothing.
(x <- y) binds y to x, but (<- y) just appends whatever y is to the context.
Should variable binding be a standard macro or primitive syntax?
It should be primitive syntax.
Even though you can implement it with a subset of the language, variables and contexts are such important semantic components that you need to add them.




How to statically expand macros when they're added during runtime.
If you define the macro outside the function,
(<- ({'a ('b -> *)} n -> (n 'b))),
(f <- (* x -> (a x))




How to do delimited continuations?
There's an AST that you capture as a function where you can parameterize the position where a sub-expression would be.
Capturing the context counts as a delimited continuation.
(& \ 0) gives the previous context.
(& \ 1) gives the current expression.
(& \ *) gives bindings and other stuff.


Are contexts nested?
No, a context is placed as a node in the AST.
Does every node get a context? No.
Functions and Sequences get a context.
Macros are also functions.
Default expressions are not functions.
How do I make something that's not a function?
Macros are given as functions.
However, I can just quote a lambda.
That might work.


So what's my syntax now?

eval ( ... )
function ( _ -> ... )
         ( _ _ -> ... )
collection { ... }
type [ ... ]
sum ( _ + _ )
difference ( _ - _ )
product ( _ * _ )
quotient ( _ / _ )
remainder ( _ // _ )

conjunction ( _ \/ _ )
disjunction ( _ /\ _ )
negation ( - _ )

binding ( _ <- ... )
        ( <- ... )



There's already a form of delimited continuations since the root of the AST isn't captured as part of the context.
What happens then when you do
((c <- &), (& <- c))
is this part of the program discarded?
yes because at this point the context is discarded.
no because the context is swapped in where the old context was.
how does this work with pointers???
contexts are linked lists
setting the context changes the rest of the list.



How to deal with infinite types?
The primitive types are infinite.
There are infinite possible instantiations of that type.
When I say something like (x : Number) then 'x may be any number.
Lets say I want natural numbers.
(N = [(x : Number), (? (x > 0) x _)])
I want some way of specifying a predicate.
Should be a filter.
Filter is already specified.
Language is easy to look at
All you do is determine the conditions dictating if a thing being compared to that type can be a value of that type.
Optimal is specifying predicates.
You have a boolean expression.
There's a program which checks the boolean expression.



How do I destructure objects.
Lets say I construct a function.
How do I destructure it?
(f <- (T -> t)),
((f \ 0) = T),
((f \ 1) = t)
How do I destructure a type?
You select the value.
(T <- [1 2 3]),
((T \ 0) = 1)
What about infinite types?
(Collection \ 0)
That returns * since the first member of any collection can be *




Number system is anything up to Rational numbers.
Anything which is a single constant magnitude.
Anything beyond Rational requires structure beyond single magnitudes.



what should be my function notation?
parameter names first or type names first?
in the case of functions, parameter names first makes the most sense as in (x -> x) representing the identity function.
but I also make heavy use of uninterpreted functions which purely map one thing to another.
uninterpreted function are (T -> T)
making an interpreted function out of an uninterpreted function requires a parameter such that (T x -> T)
this doesn't follow the usual notation of (e : T) where 'e is an expression and 'T is a type.
perhaps make all functions uninterpreted, unless you add a type definition such as ((x : T) -> T)
or simply if there are two things, then the parameter comes first, (x T -> T) or the identity function as (x * -> x)



Pattern ambiguity.
(<- ({'f A} -> t)),
(<- ({'f *} -> T)),
(f (A))
does this return 't or 'T?
So sub expressions are always evaluated before the outer expression.
This expression returns 't.
It will always return 't.


How to do pointers?
I have a reference operator '@.
Applying the operator to anything produces a reference.
Applying the operator to a reference produces the referenced object.
How to reference a reference?
A special case '@@.....
If I'm using a special case which always returns a reference, then that should be the default since it's guaranteed.
So then @ produces a reference.
What happens if I evaluate a reference by itself?
(x <- (@ t)), (x) => t


Solution to the Expression Problem.
Given a data abstraction 'D, and some functions on it, 'f, how can you 
arbitrarily extend the set of functions over 'D and the structure of 'D while 
remaining sound?
You can as long as the extension creates a supertype.
Given a redefinition function (D' (t Type -> (? (t > D) (D <- t) D)))


What about function notation?
I really want to have the identity function
(x -> x)
but also uninterpreted functions
(T -> T)
How do I get both?
I also want to use both at the same time.
(x T -> (x : T))
(x * -> x)
Simple, if there's a sub-expression, it's a type
((T) -> T)
if there's none, it's a parameter
(x -> x)
How do I write this?
If I want a parameter by itself, I do
((x) -> x)
If there's multiple parameters or multiple nestings, that's a syntax error.



How to do macros?
These are functions that are evaluated before the rest of the program.
I don't like macros, they have their own scope requirements and can affect the resultant program in strange ways.
Macros are better as just functions with special treatment.
This also allows them to be typed.
Additionally, compilation can still erase them if needed.



I need a type algorithm, a unification algorithm, and a quantification algorithm.
Unification isn't so important. 
It's hard to determine how something is unified and different implementations may get different solutions.
Unification is an abstraction above what's needed.
What about quantification?
Quantification is important.
Say I have a function,
(f : (T -> T))
now I apply it to an independent variable, (f (x : T))
What happens?
You get T back out.
Do you get a subset of T depending on what 'f does?
No.
What about 
(x : Number), (x + 1)
You get 'Number
What about 
(x : Collection), (x / T)
You get 'T
What about 
(f : ((x) -> 2)), (n : Number), (f n)
you get 2



How to make a macro?
You do a function from syntax to syntax.



What about a type algorithm?
How do you decide the supertype and subtype of a type?
You have to search the context for all types and then compare to see which is a superset of the type.
How does this work with infinite types?
Compare the conditions.
Each infinite type results in a series of value comparisons.
These are decidable.
The superset is the one with less value comparisons.



I want to just be able to write a function
(x -> x)
but this requires that I can quote things in expressions.
Symbol is a data type of a symbol
Symbol* is a quoted symbol
Expression* is a quoted expression
So you can create function maps by doing
((T) -> T)
Where the function isn't parameterized.
Or is a function always parameterized.
(x -> T)
(x -> (x : T), T)
What do I do for maps then???
I still want to be able to do a function that's just one thing to another.
Lets say match over A B C

{
	(x -> (x : A) B)
	(x -> (x : B) C)
	(x -> (x : C) A)
}

{
	((A) -> B)
	((B) -> C)
	((C) -> A)
}



Type theory is that a type expresses all possible results of an arbitrary computation.
Thus types are formed by observing arbitrary computations and other computations can be limited by a type.
This system is expressive, but incomplete because there is an unlimited number of computations for which all possible results cannot be observed.

How to do the length of a collection that starts with 1?
[(m : Collection), (? ((m \ 0) = 1) m _)]


There are some programs for which all results can be observed, but not counted.
nth provides a means of specifying quantified types which can represent the observed results of a program without counting every individual result.
a finite type is a collection of all possible unique results from a computation.
a quantified type is a collection of comparisons which must be true for all values of the type.



so if my functions are either 
(x -> x)
or 
((t : t) -> T)
then how do I create a macro?
should macros even be first class?
yes, because then syntax is uniform.
The entire point is prefix notation for everything is actually a shite idea.
So there needs to be a way to specify actual expressions.
How to provide a macro to the context?
I want to specify the type and the parameter at the same time

Because I want to make an expression as 
(x {'f ('x -> Number)} -> )

also should there be more than one parameter?
because currying is terrible in lisp.
f g h x

lets say I wanted to combine two strings
(cat : (s1 -> (s2 -> (s1 + s2)))),
((cat "a") "b")
or I would say
(cat : (strings -> ((strings \ 0) + (strings \ 1)))),
(cat {"a" "b"})



So a function is either a generic type or a parameterized expression.
((t) -> t)
or 
(x -> y)
if I wanted to make a macro, i need to be specific about the type of node and provide a parameter name.
this is expressed as
(<- (x -> (x : {'f Number}), ((x \ 1) + 1))), (f 1)



where can i use the period dot?
is it useful?
can it be a shorthand for destructuring a collection?
No that's just the same as lambdas. 
you provide named arguments as
((x -> ((x 'n) + (x 'm))) {('n -> 1) ('m -> 1)}
but can't you just allow multiple argument functions?
nope. look at how cracked this pattern would be.

(f -> (f : [(c : Collection), (? ((^(c \ 0)) = Function) c _)]))


(x . (x + 1))
instead of arrow notation you use the dot.

(x <- (@ 1)),
(. x)



make a recursive type for boolean expressions.

(B : [{Boolean ['/\ '\/] [B Boolean]} {'- [B Boolean]}])

what about for numbers?

(md : {Number ['* '/] [Number md]})
(as : {[md Number] ['+ '-] [as md Number]})
(math : [md as])
1 + 2 * 3
(3 * 2 + 1 * 4)
this doesn't work because it doesn't enforce which sub-expressions are evaluated first.
maybe if I define which ones are evaluated first it would work.
too much work
don't bother.



what's the difference between 
'x and '(1 + 1)
there is no difference, they're both quote data.



how do I do exceptions and effects.
do i actually need parentheses if I can specify patterns?
kinda?
depends, can you specify all expression boundaries so that they're inferrable?

'( Expression ')
'[ Expression * ']
'{ Expression * '}
Number '+ Number
Symbol '-> Expression
'@ *
I can't reason about structures if they need to be deserialized though.



Specifying collections.

{Function} + Collection




arithmetic

(addition : {[Number multiplication division modulus] '+ [Number multiplication division modulus]})
(subtraction : {[Number multiplication division modulus] '- [Number multiplication division modulus]})
(multiplication : {Number '* Number})
(division : {Number '/ Number})
(modulus : {Number '// Number})

(math : (({Number} + ['+ '- '* '/ '//]) + [{Number} math]))
(logic : 
	[
	 ({'-} + [{Boolean} logic]) 
	 ({logic} + {['\/ '/\]} + {logic})
	])



what is my syntax for data type constructors?
say 
(x <- (register))
(x <- (register (1 + 1)))
it's a type and you have operations on it.
how do you update the value of a register?
you give it a value

{Register Register}
{Register Number}
Register is an entity.
It's separate from numbers.



what are data types?
are they "storage types" or "environment types"?
"environment types"

You can't have random self-modifying structure.
Double down on lisp and pattern matching.
Function application pattern is anything that starts with a function
[(m : Collection), (? ((: (m \ 0 )) = Function) m)]



how do i describe data?
There's three types, Byte, Register, Reference.
You can have sub-types.
(Reg-t <- [(d : Register), (? (d > 3) d)])
Everything is a value of Data.
What do I want to describe?
A sequential organization of data in storage.
Collections already cover sequence.
There needs to be a way to specify that you want the contents fo a collection to be adjacent.


All bindings are discarded?
That makes no sense.
Should there be some kind of inverse closure where everything that's used is preserved?