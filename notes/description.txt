ASC is a general purpose programming language.
It has capabilities for unbounded abstraction but also provides basic interfaces to the underlying environment.



ASC syntax is comprised of numbers, symbols, and some limited punctuation.
Syntax is used to compose a program model.
There is a one-to-one correspondence between the construction of a program model and how it is written.



Default Expressions are

Constructors:
- Collection		[("{" * "}") (* '. *)]
- Surface		[(* '| *) (* '| Symbol *)]
- Type			("[" * "]")
- Function		[(* '-> *) (Symbol '-> *)]
- String		("\"" * "\"")
- Expression		("`" *)
- Data			(";" * ";")
- Symbol		("'" Symbol)
- Number		[+-]?[0-9]*[\.\/]?[0-9]*?\^?[0-9]*?
			A symbol consisting of all numerical digits,
			optionally prefixed with a plus or minus,
			optionally interceded by a decimal dot or fraction,
			optionally suffixed by an exponent.

Operations:
- Compute		[("(" * ")") ("(" Expression ")")]
- Arithmetic		(Number ['+ '- 'x '/ '//] Number)
- Boolean Logic		(Boolean ['/\ '\/ '-] Boolean)
- Negation		('- [Boolean Number])
- Destructure by Type	(Collection '/ *)
- Replace by Type	(Collection '/ * *)
- Destructure by Index	(Collection '\ Natural)
- Replace by Index	(Collectoin '\ Natural *)
- Difference		[(Collection '- Collection) (Collection '- *)]
- Sum			[(Collection '+ Collection) (Collection '+ *)]
- Reference		('@ Location)

Comparison:
- Equality		(* '= *)
- Inequality		(* '/= *)
- Less			(* '< *)
- Less or Equal		(* '<= *)
- Greater		(* '> *)
- Greater or Equal	(* '>= *)

Computational Forms:
- Interaction		[(Collection *) (* Collection)]
- Conditional		('? Boolean Expression Expression)
- Sequence		(Expression "," Expression)

Reflection:
- Size			('## *)
- Type			('^ *)
- Cardinality		('# Collection)
- Location		("@" Collection)
- Bind			(Symbol *)
- Clobber		(* '<- *)
- Assertion		(* ': *)
- Coerce		(Type '~ *) 

Special Symbols:
- Any			'*
- Nul			'_
- This			'&



ASC has a special constant, This, or "&", which refers to the current context.
It provides access to the context as a Collection.
The context stores data, bindings, the current expression, and any other information depending on the implementation.
During computation, multiple contexts may be nested as a result of nested function calls and other stuff.
The context is also used for interactions.
One context can bind a surface in the context which can be accessed by further nested contexts.



ASC provides minimally three basic data formats, 
Word, Byte, Location.
The Word corresponds to the maximum single value which can be operated on.
Byte corresponds to the smallest individual unit of storage.
Location identifies each unique unit of storage available in the environment.
These three can be combined using a compound data constructor.
Compound data combines one or more of the three types to form a unit of a larger size.
A compound data unit is stored in a contiguous storage segment at least as large as the size of the compound data unit.
operations are performed on compound data on individual members.



Collections are a compound data formed of pairs of locations and types.
Individual members of a collection may be stored in any location.
The collection is its own compound data unit and is stored separately from its members.



Surfaces are a pair of a type and some data.
When a collection interacts with data of that type, then the surface produces its data.
Surfaces may be parameterized on the value of the interacting data.
A parameterized surface will bind the interacting data to a symbol which can be used in the expression.



An expression is stored as a structure of nested collections.
An expression is a specific sub-type of collection which contains symbol punctuation and data.



A function is a specific sub-type of collection containing a symbol, a surface, and an expression.
The function is called by interacting with its surface.
The surface will form a new context, bind the entity in that context, and then set its expression as the current expression in the new context.



Types are a specific subtype of collections where none of the elements are equal to each other.
The elements of a type collection represent possible values for that type.
An entity of a certain type must be equal to at least one of the values for that type.
Types can be quantified in which case the values of that type are represented as the result of a program rather than a collection of individual entities.
A quantified type results from a type constructor containing any computational form.



The implementation should provide the following operations:
(Read : [(_ -> *) (_ -> String) (_ -> Character)])
(Display : [((d : *),(d -> d))])
(Compute : (Expression -> *))
(Import : ([String Symbol] -> *))
(Export : (* -> _))
(Cache : [((n : *), (n -> n))])
('Extract String *)



The computation algorithm begins by constructing an initial context which contains the program model to be computed and the default expressions as surfaces.
Computation begins by finding first expression which does not contain any nested expressions.
This can be found by taking the sum of the sequence of indicies used to access a bottom expression and then comparing each sum to find the smallest.
The first expression will have the smallest sum in every case.
The computation algorithm will then use the first expression to interact with the context.
If the interaction produces nul, then the computation algorithm will construct a semantic error and interact with the context.