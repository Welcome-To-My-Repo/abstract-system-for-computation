This text file describes what aspects of ASC have been fixed.

ASC is an environment for reasoning about and performing computation.

Syntax: 
underscore signifies one expression
elipses signifies multiple expressions.

	Collection:	{ ... }
	Adjacent:	_ ^ _
	Type:		[ ... ]
	Function:	_ -> _ 
	Expression:	( ... )
	Expression:	... .
	Compound:	... , ...
	Import:		! _
	Link:		!! _
	
	logic and:	_ /\ _
	logic or	_ \/ _
	logic not:	_ -. _

	less:		_ < _
	greater		_ > _
	equal:		_ = _
	inequal:	_ /= _

	bind:		_ : _
	clobber:	_ <- _
	cast:		_ ~ _
	
	boolean cond:	? _ _ _
	map:		_ | _
	
	add:		_ + _
	mul:		_ * _
	sub:		_ - _
	div:		_ / _
	mod:		_ // _
	
	type select:	_ / _
	index select:	_ \ _
	cardinality:	# _
	
	type:		& _
	size:		## _

	Location of:	_ @
	at Location:	@ _

	function call:	_ _
	map:		_ _

Special Constants:
	This		(%)
	Any		(*)
	Nul		(_)
	Boolean
	True
	False
	Register
	Byte
	Character
	Symbol
	Collection
	Function
	Type
	Expression
	Location

Thete's no operations for union, intersection, and complement because those can be created from functions.
Algebraic operations are provided because they work on Registers in constant space.

The concept of "this" which represents the evaluational context as a collection.
Collections and functions create new contexts.
When evaluation of a function or collection completes normally, the context is replaced with the result.
The context can be replaced with the result because the context is not connected to the data flow of expressions being evaluated.
When evaluating inside a function or collection, you can clobber This to yeild a
result of whatever you clobber it with.


Collections encapsulate all their bindings.
They are not visible to the external context.

Everything in the environment has a type, location, and size.
Any entity in the context can be queried for its type, location, or size.



ASC has a bunch of built in reflection.
It should be possible to create a program that generates an expression structure, compiles it, and exports it to a standalone executable.



Compilation and interpretation are just forms of the eval function.
Compilation is the process of caching an evaluation so that it can be quickly repeated.
Caching an entity involves anticipating the state it will be in after evaluation and only leaving components unevaluated if they depend on external values.
Interpreting is just plain eval.
Expressions have to be queried and their results calculated.



Read and Eval are interleaved as the function "Compute"
It accepts any input assuming the input represents a program.
The input can be a string, or some other structure representing a program.



The environment is an image.



Elements of a collection are not required to be physically adjacent unless they are specified as adjacent using the constructor ^.
