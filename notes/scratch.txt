no comments, annotations instead.
you can ask the compiler to look up documentation about bound variables.
annotation operator is ` and it takes a string after it.
so 
	x = 1 
	x ` "bound to 1"



ASC is a tool, just like any other.
More specifically, ASC is like an angle grinder. 
Angle grinders are used in almost every craft because they are powerful, precise, and highly versatile.
The only stipulation is that you have to know how to use one properly.
For example, the object you're grinding must be held in a stable position and there's only a few safe ways to hold the angle grinder.
If you use one the right way, angle grinders come with many safety features so that you will never be surprised or hurt.
Unfortunately most craftspeople don't bother to learn proper safety techniques before they use an angle grinder.
This often results in cases of permanent maiming or even death.
When you use ASC properly and safely, you'll create practical and beautiful things.
Make sure to learn what proper use and safety mean for ASC or else you and others could get hurt.



================================================================================
Low Level System API implements something like Vulkan for rendering and 
general purpose compute
================================================================================



the concept of This (%).
"This" refers to the immediate context.
The context is the collection of bindings.
For example:
in a block
	x : 1 , This x = 1 . 

in a collection
	{x : 1 .  This x} = {x : 1 .  1}



Implicit Qualification:
Implicit quantification involves applying an operation to a type, implying that
the operation is performed for all values of that type, producing a new type 
that represents all the values possibly returned from that type.



How do I describe a self describing system?
Corecursion.
I say that a system "x" is given the properties "y", which are defined by a system "x".
I describe ASC as a program which interprets ASC, written in ASC.
Then the definition is a matter of what external information is required to comprehend the program.
What external information is required?
... Default expression syntax
... Default expression semantics
... Requirements of a correct program
... Requirements of the default module
... The manner in which evaluation can be reconciled with the real environment.
Oddly enough type rules are not external information, but are part of the interpreter.



How does execution happen?
You submit a program definition to the environment.
This program can affect other programs by modifying the context.
A program depends on the context.



What does the environment provide?
... Storage
... Placement

What does evaluation provide?
... entity duration
... structured context



ASC environment functions:
... Compute (effectful)
... Compile (discrete)
... Describe (discrete)
... Disassemble (discrete)
... Display (discrete)
... Export (discrete)
... Import (effectful)
... Inspect (discrete)
... Link (effectful)
... Obfuscate (discrete)



How to introduce a new expression?
An expression is a collection of types and symbols provided as the surface for the context.

	(Expression ".") : Expression. | e -> (e_0)
	(Expression "\n") : Expression. | e -> (e_0)
	("(" Expression ")") : Expression. | e -> (e_1)

You want to be explicit that you're making an expression, not just another surface.
This also makes the context more easily searchable by type because you can simply do
	% / (Expression | *) to get the collection of all the expressions.

How does select by type work?
It compares the possible values of the selecting type and if an element is value-equivalent to any of them, then it is yielded.



Expressions are just a specially interpreted collection.
Except that everything can be a specially interpreted collection and I turn into a lisp. blech!
Expressions are their own datatype.
Quoting expressions and stuff is hard to represent as a collection.
You start overloading collection semantics with special cases for computation.
A quoted expression represents a whole program rather than just a collection.
What's the notation for a collection then?
The semicolon,
	; "a‚Äù T 'T ;
That makes a new expression.
What operations are available for an expession?
- quote
- unquote
- destructure
But aren't expressions the same as collections?
What if I want to write an expression that builds an expression that writes itself?
That would be a collection.
You can just take an expression to be a collection though.
	('f 'x):Expression
	{'f 'x}:Expression
	; 'f 'x ;
these are all the same, but the last line allows you to avoid writing out the type when its use is obvious to the user.
In all instances, an expression is a collection of syntax entities.
	Expression: (( 2 '- 1) '+ 1)



Need semantics for interpreting numerical and string constants.
There's textual data which acts as a constructor.
All symbols are strings.
Numerical symbols are constant values.
The value expressed by a number is exact.
Semantics for how a number is interpreted should be at the program level, not a compiler thing.
The rest of the syntax is the same.
A numerical symbol is a constant.
A string is not a constant.



How to clobber stuff.
What is a binding?
A binding is a program that yields some entity held in the context.
There's two ways, accessing a collection or using an expression.
Binding is
	x = 1
resulting in
	; 'x ; | %\(# %) <- 1
in plain english, binding an unbound symbol first clobbers the value being bound into the context. Then it exposes it as a surface using an expression containing the symbol being bound.



Compute has a type which is dependent on the value the expression produces.
If I say 
	(n -> n + 1) (compute "string")
I get a type error because compute doesn't produce a numerical value.



Should there be error effects?
Say
	f = x -> x + 1. ,
	f (1 2)
should application use an error handling thing?
No.
What about
	x : [n = Value, ? n > 30 n _],
	x = random.



what happens when I run a program?
I have an expression
	1 + 1
this is Read as 
	;1 '+ 1;
which can be passed to the context to recieve a result.



Is there a way to cause a dynamic error during computation? 
Yes, but it's hard to achieve.
	c = {% ``x},
	% <- c .
This is a type error



How to tell the difference between an expression and a collection?
	{ {'a 'b 'c} '/ 'a}
Because you need to have a quote and unquote.
	quote ({'a 'b 'c} / 'a)



How do you treat a symbol as data?
The single quote
	'symbol
How do you treat an expression as data?
Single quote with parentheses
	'(expression)
How do you evaluate a quoted symbol?
	('symbol)
How do you evaluate a quoted expression?
	('(expression))
How do you destructure a quoted expression?
'(1 + 1)\0 = 1
'(1 + 1)\1 = '+
'(1 + 1)\2 = 1
Why are some symbols quoted but other symbols are not?
It depends on the expression form.
In the case of addition, it's 
	; Value '+ Value ;
quotation works by using the apostrophe to quote an expression
	' 1 + 1
	' n -> n + 1
You quote a symbol as
	` x
or
	` x.
to avoid ambiguity

The expression constructor is two semicolons.
It allows shorthand notation for various forms of repetition.
	; Value 'x "%" [A B] * ;



How does evaluation work?
The initial context has a number of built-in functions which facilitate the default expression semantics.
A function entity has an implementation dependent representation.
All the default types depend on the implementation and environment.
What is my evaluation model?
Compute gets an expression, it passes the expression to the context surface.
It the expression is defined, then the context returns some other expression to compute.
This process repeats until compute passes a default expression and recieves an entity.
What about functions?
Functions are an assumed type and application is a default expression.
Applying a function is managed by the environment.
Functions contain expressions though.
Functions are equivalent to binding a symbol and computing a quoted expression.



Evaluation model is this, for every function call and surface interaction, a new context is created.
In each context is
	{ External-Context : Collection
	  Current-Expression : Expression
	  Other-Stuff : * }
Once Compute completes the current expression, it replaces the context with the result in the external context.
If you replace the context with a value, it short circuits the computation.
If you replace the current expression with another expression, it short circuits the computation, but you keep the same context.



How is an expression evaluated?
	"First bind an expression as a surface",
	% + {{'add Value 'to Value}| e -> e\1 + e\3},
	"Then you use the expression",
	add 1 to 2.
Now read reads in the expression.
You get 
	{'add 1 'to 2}
Compute passes it to the context surface
	(e\Expression %)
It recieves another expression and calls Compute on it.
What computes compute?
The environment.
The environment provides the basic functions from outside the scope of the language even though the language can inspect its own environment.



Collections use result polymorphism.
	1 {1 | 'a  1 | 'b} : 'b = 'b

Can functions be defined for multiple things?
Yes.
	f : x -> x + 1,
	f : x -> x / T,
	f {n:T} = T,
	f 1 = 2.



What happens when you clobber the context?
How does it affect control?
Because the expression being evaluated is inside the context.
	n = 1,
	n <- n + 1,
	% <- n + 1,
	"code beyond here is not evalutated",
	n <- n + 1.
Why?



What is the context model?
In a context, you have
- The expression being evaluated
- The external context
- Bindings
How is this structured?
External context is first.
Then the expression being evaluated.
Functions are deferred computation.



Compute takes an experession and passes it to the context.
The context returns another expression.
What does that look like?


	Compute = e -> 
	 e:Collection,

What is a surface? 
It's a way to access information inside a collection.
When are surface interactions evaluated?
During execution.
	x : 1,
	c : {1 | 1},
	c x = 1

all expressions are reduced to 
- function application
	f x
- evaluation
	(x)
	(x y z)
- Conditional Evaluation
	? p q r
- sequence
	f x, g x
- interaction
	x c
- constant
	1
	'1
	"1"
	{1 1}
	[1 1]
- Default Operation
	Algebra
	Boolean logic
	Comparison
	Subscript
	Destructure
	Type of
	Size of
	Reference
	Dereferece

These operations are built into the environment and computing them produces implementation dependent behavior



What is my model for expressions?
An individual expression is a collection of constructors, punctuation, and nested expressions.
A quoted expression allows you to read in an expression as an unevaluated expression structure.
So 
	`1 + 1 = (1 '+ 1) = {1 '+ 1}
What about
	`1 + 2 - 3 = ((1 '+ 2) '- 3) = {{1 '+ 2} '- 3}
How do you tell the difference between an expression and a collection?
You quote punctuation differently than you quote a symbol.
Punctuation and types determine an expression.
Lisp only needs one quotation notation because the function is always the first in the list.
I can't because the function may have any form such as juxtaposition of two types of elements.
So how do I quote an expression?
The backquote.



How do I treat an expression as data?
An expression is a collection of symbols and other expressions.
How do you create an expression?
	e : Expression
	e\0 : 1
	e\1 : '+
	e\2 : 1
	e = `1 + 1
	e = (1 '+ 1)
If I say
	x : 1
then
	Compute ('x) = 1



VERY IMPORTANT PROPERTY
	c <- {x = y  y = x}
	c\0 = c\1



recursive expression possible?
	% + {'a} | 'b,
	% + {'b} | 'a,
	'a



how does string syntax work?
You say that there's some stuff in between two quotation marks.
Inside quotations, the backslash character has special syntax.
What you need is a character-by-character parsing algorithm.
I need two things, the type of a stream and the ability to express something that repeats.
A character type is any expression that's evaluated to produce a character.
Read is different. 
It has a collection of characters.
Can't be reader macros because you can jump in and out of interpreting characters.
Read takes a string and turns it into a data structure.
Does read bind things?
No.



IMPORTANT-----------------------------------------------------------------------
	? e : T 
	  T : e
	  ^e \= T
"if computing 'e' yeilds a value of type 'T', then it follows that it's possible to compute 'T' in such a way as to get 'e'.



How to make a list?
You have to create a new context where you grab everything.
Then you have to set a new context where you build the list structure.
I need a way to set a new context for a specific expression.
Say you can have any "c" between "a" and "b".
The expression returns the number of "c".
This requires two things, an intermediary value holding the number of "c".
And an order in which the "c"'s occur.
Order is determined by the order of the stream.
The "c"'s are in a sequence already.
So the solution is to allow new context to be set around a specific expression.
Given the expression form 
	{'a 'b ... 'c}
There's two expressions,
	{'a e 'c} 
and
	{'b ['b _]}


Expressions for a context are stored in a collection.
	% 'Expressions
They are distinct from the rest of the collections by location.



what are maps? 
Aren't they just closures?
Can't you do that with syntax?
Not really.
	d : {'a | 'b  'c | {1}}
	'a 'c d = 'b
You can't do this with closures.
There's a mechanism for propagating across contexts.



ASC is an inductive pure type system.
The ":" and "[ .. ]" operators allow the construction of new types which are just terms on a higher stratification.

So then the ASC type system consists of sorts or entities "A"
And has the rules,
	(A_0,A_0)				.... Base
	(A_n,A_n),(A_n,A_m),(A_m,A_n),(A_m,A_m)	.... Inductive
so what does this look like in ASC?



Symbols are any sequence of alphabetic characters with no white space.
Values are symbols prefixed with a single quote.
Types are one or more unique values.
Types can occur as values in other types.



not worrying about the inductive proof.



what is the nature of maps and collection surfaces?
theres a collection.
it has some elements.
you can access those elements by destructuring the collection.
you can also provide more complex polymorphic interactions.
what do i mean by interaction?
is this a function?


IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ASC is not based on the Lambda Calculus, It's based on objects.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
what do I mean by that?
A function is actually an abstraction in my language.
The most primitive abstraction for "doing something" in my language is 
passing an event to a collection.
The primitive ops are
- collection constructor	{ ... }
- clobber			_ <- _
- bind				_ | _
- sequence			... , ...
- this				%
- deconstruct			_ \ _
- cardinality			# _
- value				' _

is this all I need?
Yes
So how to do recursion?
By an event passing it to itself.
Self reference.
{* | % *}




Semantics are based on interactions.
Rather than message passing, one object is introduced to another with a reaction defined.



If I have a collection
	c : {'a 'a 'a}
and I compute
	c / 'a
i get 
	{'a 'a 'a}
but how do i get one of the elements when they're the same type?
By casting. 
If I have the same collection and I cast it to a nested collection
	c ~ {'a {}} / 'a = 'a
This is a terrible kludge for just indexing.
However the index of a collection is unique to each collection.
What if you can index based on anything?



Get rid of function notation an functions alltogether.
You don't need them.
Instead of passing functions, you pass around collections.
If you want to make a function, all you do is
{* -> p}
You can't really shadow anything though which makes things hard.
But on the other hand, context and binding in the context are first-class structures.
How would this look?
It would look terrible.



What is binding?
Binding is when you use a symbol as an expression.
	(Expression : {'x}) | 'value
Binding is another form of macro.



What are my semantics for computation.
Compute is given a program representation as some "p" where
	(p)
and P is composed of one or more nested expressions.



What order should computation reduce expressions?
It finds the first expression that has no nested expressions.
It uses that expression to interact with the context.
The context produces more data or another expression.



What if I use period like a lambda abstraction?
	x . x + x
How do I talk about functions in a generic way?
when i talk about the type of a function, i don't talk about the symbol used as a parameter.




how do pointers work?
they arent typed.

x . x + x



	x <- 1
	y <- x @
	z <- y @
How do pointers work?
Are they typed?
Yes.



So what's my fucking notation now???

Assignment: _ ; _
Binding: _ : _
Parameterization: _ . _
Application: _ _ 
Interaction: _ _

How does juxtaposition work?
Can you juxtapose in either direction?

	f : Function,
	c : Collection,
	x c f,
	x f c,
	f x c,
	f c x,
	c x f,
	c f x

so you can actually juxtapose in any direction.
What about currying?
	
	g : (Function *): Function,
	g c f x x = g(c f x)(x),
	g c f x c = g((c (f x))c)
what is the algorithm here for application?
you have a sequence of juxtaposed terms.
how are they reduced?
You have an something that can be applied and something that can't, then there's several cases
- a a	the first is applied on the second
- a c	the first is applied on the second
- c a	the second is applied on the first
- c c	none are applied, this is two separate expressions.
So aren't infix operators just
{* | x . {* | y . op(x y)}}



I don't know if I like my syntax.
The symbols and names for things aren't that great.
How do I do better?

Constructors are obvious
Types:		[ ... ]
Collections:	{ ... }
Compute:	( ... )

Type Binding is the colon	:
Clobber is the semicolon	;
They're both forms of binding.

I also need shortcuts to refer to
Type of Types:		[]
Type of Collections:	{}
Type of Functions:	()
Type of Expressions:	()
Type of Symbols:	Symbol
Type of Anything:	*
Type of Nothing:	_
Is there any point where I would need an empty version of any of these?
No, in most cases where I'm talking about empty constructors, I'm talking about the generalized types of those.

What about destructuring collections?
You can select by type or by position.
Select by type:		_ / _
Select by index:	_ \ _
Might be a complaint that these operators aren't clear.
What else can be used for selecting?
Underscore, colon, semicolon, period...
I think the forward and backward slash are fine for this.

Should the function constructor be an arrow or a dot?
x . x + x
x -> x + x
An arrow. It's more clear what's going on.
If that's the constructor, how do I write a function type?
It's different than a function constructor because I'm not talking about which symbols I'm binding as parameters.
It would be more like 
"Something applied to something computes to something"
Is a function the same as an expression?
Yes actually.
So then a function of A to B would be 
	(Function A : B)



What's minimal ASC?
no types
everything is a Value
You have arithmetic
the ability to clobber
equality comparison
no variable names, everything is from the context.



Fixed context elements:
% / Expression
% / 


How to identify what is an expression in the context and what is a normal binding?
Make an expression type.
({'b} | 1) : Expression



A property where
(x -> x : 1) *  = 1



What happens when I clobber a surface?
% ; % + 1 | 1, % 1 ; 2
You can't actually clobber a surface.
You can replace it with another surface.



If you need a context then you need to forcibly enter a new context.
How do you do that?

%\#% <- Expression : 
	{'a} | % <- 	{
			% 
			count : Value 
			(Expression : {'b} | count <- count + 1)
			(Expression : {'c} | % <- %)
      			}



What's the minimal syntax?
	{ ... }
	( ... )
	_ <- _
	%
	_ = _
	_ /= _
	_ < _
	_ > _
	@ _
	^ _



how does construction work?
You claim a portion of storage not less than the storage requirements of the constructed object.
The storage portion is treated as a place and is given a unique place value.



how are collections made?
Can elements in a collection be in separate locations?
Yes. 
The collection is an object and the objects "in" the collection are separate.
Does this mean that the entities in the collection can be in non-adjacent locations?
Yes.
How to enforce something has an adjacent location?
What information does a collection actually contain then?
The location of each of its elements.
Is there any case where type information should be dynamically included?
Type information is stored separately from the program.
So what happens if I query the type of something?
	^ x
The type information is constant.
What is type information?
The program that results in the type.
So if 
	x : T
then
	^ x = T
you're not actually querying the type of the binding.
You're querying the type of the entity that the binding evaluates to.
So 
	^ [a b c] = Type
	^ (a : [a b c]) = [a b c]
	^ 1 : [1] = [1]
How are types held in a context?
Say that you make a new type. 
How is it incorporated with other types?



The type system is not affected by context?
Or is it?
If I have 
	a = Type, b = Type, c = Type,
	x : [a b] = b,
	y : [a b c] = b,
	^ x, ^ y
the type needs to be bound in the context.
if the type is released from a context then you can't use it.
Also how about enums?
	T = [a:Type b:Type c:Type]
what does an unbound symbol in a type mean?
That it's a value of that type.



how does each expression handle unbound symbols?
1	(a)
2	[a]
3	{a}
4	a = 'e
5	a : t

1: returns a semantic error that "a" is not computable
2: binds 'a as a value to the type
3: returns a semantic error that "a" is not computable
4: binds "a" to 'e
5: binds "a" to t
Are these computed?
Yes, compute dispatches a program which decides how to bind the unbound symbols.



a collection is a separate entity from its elements.
a collection and each of its elements each have unique locations.
what about data that's adjacent?
use a value type for that.
you have default values and you can create new compound values from that.



what about operator precedence in arithmetic?
	Sum : Number
	Product : Number
	Exponent : Number
	% <- % + {}



There's a collision between how a function is constructed and how it's typed.
A function constructor takes a parameter name as a symbol, but it does not allow for an input type to be specified with the parameter.
The purpose of a function is twofold. 
It creates a symbolic substitution of a variable with an input parameter.
It encloses an expression in a context which is evaluated later.
Thus a function is structurally typed according to the input-output pair, and it exists as a syntactic form.
Using arrow notation, how should a function be given a parameter and a type?
        f : T -> t
        f = x -> y
So the function constructor has the form
        {Symbol '-> Expression}
When should the function constructor have the form
        {Expression '-> Expression}
that's simple, it would be
        f : (T) -> t
        f = x -> y
Because the type of () always yields an expression.



Data description.
The environment assumes the presence of two capabilities:
The ability to hold data while a transformation is being applied.
The ability to store data while it is not being held.
A minimum of two data formats are required, a format for transformations and a 
format for storage.
The storage format is called a Byte.
The transformation format is called a Word.



What are my terms?
A collection can include a surface as an element.
A surface maps some entity to another entity, the reaction.
A program may interact with a Collection by providing it with an entity matching the type of entity in the surface.
The collection will then produce the reaction entity.



How do I create expressions?
By backtick and parens.
`(1 '+ 1)
It's the same as asserting that you're creating an expression
(1 '+ 1):Expression
So how would you do a macro?
	% <- % + `{'o T} | t, o T
=
	`(`(`(%) '<- `(% '+ `(`({'o T}:Expression) '| `(t))) ', `('o T))
=
	`(
		`(
			`(%)
			'<-
			`(
				%
				'+
				`(
					`(
						{'o T} : Expression
					)
					'|
					`(t)
				)
			)
		)
		',
		`(
			'o
			T
		)
	)
Here's the problem, this is a nested expression which introduces a macro to the context and then uses that macro.
How is this possible?
Read determines the innermost expression, then computes it.
So this means that Read and Compute must be interleaved.
Or this means that Compute is the same function as Read.




A hard limit of the universe is that if I have a compound expression
	e1, e2
where the well-formedness of "e2" depends on computing "e1",
then I cannot verify that "e2" is well-formed without first computing "e1".



If my language is dynamically typed, can I stil check expressions?
Say I have two functions,
	f : (a) -> b
	g : (d) -> c
and I combine them,
	(g f a)
I get a type error when the reader determines 
	(f a)
without evaluating the function.



the type of an expression is known ahead of time because it's an interaction and interactions are typed just like functions are.



what if a function includes new syntax?
	f = x -> (% <- % + {'a x} | n -> n\1, a 1)



how are types taken into account?



evaluation model is stratified
you have a compound expression, 
	e1, e2
and reading e2 depends on evaluating e1, so then you would compute e1 explicitly
	compute e1, e2



so I have a context, %
it's a collection containing the grammar, the expression being computed, and any context-bounded data.
	% = {g = {}, e, d_0, d_1, d_2, ..., d_n}
I can change the grammar, the expression being evaluated, or any of the data.
I want specific behavior, when I write
	% <- e
I want the context to be replaced entirely with one evaluating "e".
when I write
	% <- {}
I want the entire context to be replaced with the new collection.
what form does the context have?
the address of the external context.
so I'm replacing part of the context.
what does the context contain?
- the address of the external context
- the collection of grammars
- the expression being evaluated
- the collection of data
so there's four things.
how do I expression these four things?
just specific indicies in %?
or do I use names?
I should use a combination of names and types

%/Expression yields the current expression
%/% yields the external context
%/Collection yields all the bindings
So there's a triple of a context, an expression structure, and a collection of bindings.



what higher order operators should I use with collections?
i have a filter operation already
	c / t
I want an operation that does something for each element.
that's just iteration.
but is it built in?
no just iterate or provide a macro.



so how do I iterate?



What's the notation for creating an expression.
It's just ( ... )
What if I want to quote a constructor?
("{" 'a 'b 'c "})
That's how you quote a constructor.



Say I have two collections
A : Collection, B : Collection
how would I make them contain each other?
A = {B}, B = {A}
This works because the collection is a separate structure than the entities. 
Rather than an infinite nested chain, it's a cycle.



collections are just vectors of pointers.
so you can easily filter append and delete from them.
How do you do that?
addition and subtraction
can you add one at a time?
no you can add multiple
{a} + {b} = {a b}
{a b} - {a} = {b}
{a} + {{b}} = {a {b}}



how do I interleave computation?
Like with my "dependent" contexts thing.
how do I say `e1` before reading `e2`?
	(e1), e2
	Compute e1, e2
how do I quote an expression?
	x <- ` 1 + 1
just the backquote
that makes an unevaluated expression
then you can eval it a bunch of times
	x <- ` 1 + 1, (x) + (x)
or you can do a tagbody
	n = 10, (loop <- ` ?(n > 0) n <- n - 1, (loop) n)