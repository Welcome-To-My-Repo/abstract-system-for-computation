no comments, annotations instead.
you can ask the compiler to look up documentation about bound variables.
annotation operator is ` and it takes a string after it.
so 
	x = 1 
	x ` "bound to 1"



ASC is a tool, just like any other.
More specifically, ASC is like an angle grinder. 
Angle grinders are used in almost every craft because they are powerful, precise, and highly versatile.
The only stipulation is that you have to know how to use one properly.
For example, the object you're grinding must be held in a stable position and there's only a few safe ways to hold the angle grinder.
If you use one the right way, angle grinders come with many safety features so that you will never be surprised or hurt.
Unfortunately most craftspeople don't bother to learn proper safety techniques before they use an angle grinder.
This often results in cases of permanent maiming or even death.
When you use ASC properly and safely, you'll create practical and beautiful things.
Make sure to learn what proper use and safety mean for ASC or else you and others could get hurt.



================================================================================
Low Level System API implements something like Vulkan for rendering and 
general purpose compute
================================================================================



the concept of This (%).
"This" refers to the immediate context.
The context is the collection of bindings.
For example:
in a block
	x : 1 , This x = 1 . 

in a collection
	{x : 1 .  This x} = {x : 1 .  1}



Implicit Qualification:
Implicit quantification involves applying an operation to a type, implying that
the operation is performed for all values of that type, producing a new type 
that represents all the values possibly returned from that type.



How do I describe a self describing system?
Corecursion.
I say that a system "x" is given the properties "y", which are defined by a system "x".
I describe ASC as a program which interprets ASC, written in ASC.
Then the definition is a matter of what external information is required to comprehend the program.
What external information is required?
... Default expression syntax
... Default expression semantics
... Requirements of a correct program
... Requirements of the default module
... The manner in which evaluation can be reconciled with the real environment.
Oddly enough type rules are not external information, but are part of the interpreter.



How does execution happen?
You submit a program definition to the environment.
This program can affect other programs by modifying the context.
A program depends on the context.



What does the environment provide?
... Storage
... Placement

What does evaluation provide?
... entity duration
... structured context



ASC environment functions:
... Compute (effectful)
... Compile (discrete)
... Describe (discrete)
... Disassemble (discrete)
... Display (discrete)
... Export (discrete)
... Import (effectful)
... Inspect (discrete)
... Link (effectful)
... Obfuscate (discrete)



How to introduce a new expression?
An expression is a collection of types and symbols provided as the surface for the context.

	(Expression ".") : Expression. | e -> (e_0)
	(Expression "\n") : Expression. | e -> (e_0)
	("(" Expression ")") : Expression. | e -> (e_1)

You want to be explicit that you're making an expression, not just another surface.
This also makes the context more easily searchable by type because you can simply do
	% / (Expression | *) to get the collection of all the expressions.

How does select by type work?
It compares the possible values of the selecting type and if an element is value-equivalent to any of them, then it is yielded.



Expressions are just a specially interpreted collection.
Except that everything can be a specially interpreted collection and I turn into a lisp. blech!
Expressions are their own datatype.
Quoting expressions and stuff is hard to represent as a collection.
You start overloading collection semantics with special cases for computation.
A quoted expression represents a whole program rather than just a collection.
What's the notation for a collection then?
The semicolon,
	; "a‚Äù T 'T ;
That makes a new expression.
What operations are available for an expession?
- quote
- unquote
- destructure
But aren't expressions the same as collections?
What if I want to write an expression that builds an expression that writes itself?
That would be a collection.
You can just take an expression to be a collection though.
	('f 'x):Expression
	{'f 'x}:Expression
	; 'f 'x ;
these are all the same, but the last line allows you to avoid writing out the type when its use is obvious to the user.
In all instances, an expression is a collection of syntax entities.
	Expression: (( 2 '- 1) '+ 1)



Need semantics for interpreting numerical and string constants.
There's textual data which acts as a constructor.
All symbols are strings.
Numerical symbols are constant values.
The value expressed by a number is exact.
Semantics for how a number is interpreted should be at the program level, not a compiler thing.
The rest of the syntax is the same.
A numerical symbol is a constant.
A string is not a constant.



How to clobber stuff.
What is a binding?
A binding is a program that yields some entity held in the context.
There's two ways, accessing a collection or using an expression.
Binding is
	x = 1
resulting in
	; 'x ; | %\(# %) <- 1
in plain english, binding an unbound symbol first clobbers the value being bound into the context. Then it exposes it as a surface using an expression containing the symbol being bound.



Compute has a type which is dependent on the value the expression produces.
If I say 
	(n -> n + 1) (compute "string")
I get a type error because compute doesn't produce a numerical value.



Should there be error effects?
Say
	f = x -> x + 1. ,
	f (1 2)
should application use an error handling thing?
No.
What about
	x : [n = Value, ? n > 30 n _],
	x = random.



what happens when I run a program?
I have an expression
	1 + 1
this is Read as 
	;1 '+ 1;
which can be passed to the context to recieve a result.



Is there a way to cause a dynamic error during computation? 
Yes, but it's hard to achieve.
	c = {% ``x},
	% <- c .
This is a type error



How to tell the difference between an expression and a collection?
	{ {'a 'b 'c} '/ 'a}
Because you need to have a quote and unquote.
	quote ({'a 'b 'c} / 'a)



How do you treat a symbol as data?
The single quote
	'symbol
How do you treat an expression as data?
Single quote with parentheses
	'(expression)
How do you evaluate a quoted symbol?
	('symbol)
How do you evaluate a quoted expression?
	('(expression))
How do you destructure a quoted expression?
'(1 + 1)\0 = 1
'(1 + 1)\1 = '+
'(1 + 1)\2 = 1
Why are some symbols quoted but other symbols are not?
It depends on the expression form.
In the case of addition, it's 
	; Value '+ Value ;
quotation works by using the apostrophe to quote an expression
	' 1 + 1
	' n -> n + 1
You quote a symbol as
	` x
or
	` x.
to avoid ambiguity

The expression constructor is two semicolons.
It allows shorthand notation for various forms of repetition.
	; Value 'x "%" [A B] * ;



How does evaluation work?
The initial context has a number of built-in functions which facilitate the default expression semantics.
A function entity has an implementation dependent representation.
All the default types depend on the implementation and environment.
What is my evaluation model?
Compute gets an expression, it passes the expression to the context surface.
It the expression is defined, then the context returns some other expression to compute.
This process repeats until compute passes a default expression and recieves an entity.
What about functions?
Functions are an assumed type and application is a default expression.
Applying a function is managed by the environment.
Functions contain expressions though.
Functions are equivalent to binding a symbol and computing a quoted expression.



Evaluation model is this, for every function call and surface interaction, a new context is created.
In each context is
	{ External-Context : Collection
	  Current-Expression : Expression
	  Other-Stuff : * }
Once Compute completes the current expression, it replaces the context with the result in the external context.
If you replace the context with a value, it short circuits the computation.
If you replace the current expression with another expression, it short circuits the computation, but you keep the same context.



How is an expression evaluated?
	"First bind an expression as a surface",
	% + {{'add Value 'to Value}| e -> e\1 + e\3},
	"Then you use the expression",
	add 1 to 2.
Now read reads in the expression.
You get 
	{'add 1 'to 2}
Compute passes it to the context surface
	(e\Expression %)
It recieves another expression and calls Compute on it.
What computes compute?
The environment.
The environment provides the basic functions from outside the scope of the language even though the language can inspect its own environment.



Collections use result polymorphism.
	1 {1 | 'a  1 | 'b} : 'b = 'b

Can functions be defined for multiple things?
Yes.
	f : x -> x + 1,
	f : x -> x / T,
	f {n:T} = T,
	f 1 = 2.



What happens when you clobber the context?
How does it affect control?
Because the expression being evaluated is inside the context.
	n = 1,
	n <- n + 1,
	% <- n + 1,
	"code beyond here is not evalutated",
	n <- n + 1.
Why?



What is the context model?
In a context, you have
- The expression being evaluated
- The external context
- Bindings
How is this structured?
External context is first.
Then the expression being evaluated.
Functions are deferred computation.



Compute takes an experession and passes it to the context.
The context returns another expression.
What does that look like?


	Compute = e -> 
	 e:Collection,

What is a surface? 
It's a way to access information inside a collection.
When are surface interactions evaluated?
During execution.
	x : 1,
	c : {1 | 1},
	c x = 1

all expressions are reduced to 
- function application
	f x
- evaluation
	(x)
	(x y z)
- Conditional Evaluation
	? p q r
- sequence
	f x, g x
- interaction
	x c
- constant
	1
	'1
	"1"
	{1 1}
	[1 1]
- Default Operation
	Algebra
	Boolean logic
	Comparison
	Subscript
	Destructure
	Type of
	Size of
	Reference
	Dereferece

These operations are built into the environment and computing them produces implementation dependent behavior



What is my model for expressions?
An individual expression is a collection of constructors, punctuation, and nested expressions.
A quoted expression allows you to read in an expression as an unevaluated expression structure.
So 
	`1 + 1 = (1 '+ 1) = {1 '+ 1}
What about
	`1 + 2 - 3 = ((1 '+ 2) '- 3) = {{1 '+ 2} '- 3}
How do you tell the difference between an expression and a collection?
You quote punctuation differently than you quote a symbol.
Punctuation and types determine an expression.
Lisp only needs one quotation notation because the function is always the first in the list.
I can't because the function may have any form such as juxtaposition of two types of elements.
So how do I quote an expression?
The backquote.



How do I treat an expression as data?
An expression is a collection of symbols and other expressions.
How do you create an expression?
	e : Expression
	e\0 : 1
	e\1 : '+
	e\2 : 1
	e = `1 + 1
	e = (1 '+ 1)
If I say
	x : 1
then
	Compute ('x) = 1



VERY IMPORTANT PROPERTY
	c <- {x = y  y = x}
	c\0 = c\1



recursive expression possible?
	% + {'a} | 'b,
	% + {'b} | 'a,
	'a



how does string syntax work?
You say that there's some stuff in between two quotation marks.
Inside quotations, the backslash character has special syntax.
What you need is a character-by-character parsing algorithm.
I need two things, the type of a stream and the ability to express something that repeats.
A character type is any expression that's evaluated to produce a character.
Read is different. 
It has a collection of characters.
Can't be reader macros because you can jump in and out of interpreting characters.
Read takes a string and turns it into a data structure.
Does read bind things?
No.



IMPORTANT-----------------------------------------------------------------------
	? e : T 
	  T : e
	  ^e \= T
"if computing 'e' yeilds a value of type 'T', then it follows that it's possible to compute 'T' in such a way as to get 'e'.



How to make a list?
You have to create a new context where you grab everything.
Then you have to set a new context where you build the list structure.
I need a way to set a new context for a specific expression.
Say you can have any "c" between "a" and "b".
The expression returns the number of "c".
This requires two things, an intermediary value holding the number of "c".
And an order in which the "c"'s occur.
Order is determined by the order of the stream.
The "c"'s are in a sequence already.
So the solution is to allow new context to be set around a specific expression.
Given the expression form 
	{'a 'b ... 'c}
There's two expressions,
	{'a e 'c} 
and
	{'b ['b _]}


Expressions for a context are stored in a collection.
	% 'Expressions
They are distinct from the rest of the collections by location.



what are maps? 
Aren't they just closures?
Can't you do that with syntax?
Not really.
	d : {'a | 'b  'c | {1}}
	'a 'c d = 'b
You can't do this with closures.
There's a mechanism for propagating across contexts.



ASC is an inductive pure type system.
The ":" and "[ .. ]" operators allow the construction of new types which are just terms on a higher stratification.

So then the ASC type system consists of sorts or entities "A"
And has the rules,
	(A_0,A_0)				.... Base
	(A_n,A_n),(A_n,A_m),(A_m,A_n),(A_m,A_m)	.... Inductive
so what does this look like in ASC?



Symbols are any sequence of alphabetic characters with no white space.
Values are symbols prefixed with a single quote.
Types are one or more unique values.
Types can occur as values in other types.



not worrying about the inductive proof.



what is the nature of maps and collection surfaces?
theres a collection.
it has some elements.
you can access those elements by destructuring the collection.
you can also provide more complex polymorphic interactions.
what do i mean by interaction?
is this a function?


IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ASC is not based on the Lambda Calculus, It's based on objects.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
what do I mean by that?
A function is actually an abstraction in my language.
The most primitive abstraction for "doing something" in my language is 
passing an event to a collection.
The primitive ops are
- collection constructor	{ ... }
- clobber			_ <- _
- bind				_ | _
- sequence			... , ...
- this				%
- deconstruct			_ \ _
- cardinality			# _
- value				' _

is this all I need?
Yes
So how to do recursion?
By an event passing it to itself.
Self reference.
{* | % *}




Semantics are based on interactions.
Rather than message passing, one object is introduced to another with a reaction defined.



If I have a collection
	c : {'a 'a 'a}
and I compute
	c / 'a
i get 
	{'a 'a 'a}
but how do i get one of the elements when they're the same type?
By casting. 
If I have the same collection and I cast it to a nested collection
	c ~ {'a {}} / 'a = 'a
This is a terrible kludge for just indexing.
However the index of a collection is unique to each collection.
What if you can index based on anything?



Get rid of function notation an functions alltogether.
You don't need them.
Instead of passing functions, you pass around collections.
If you want to make a function, all you do is
{* -> p}
You can't really shadow anything though which makes things hard.
But on the other hand, context and binding in the context are first-class structures.
How would this look?
It would look terrible.



What is binding?
Binding is when you use a symbol as an expression.
	(Expression : {'x}) | 'value
Binding is another form of macro.



What are my semantics for computation.
Compute is given a program representation as some "p" where
	(p)
and P is composed of one or more nested expressions.



What order should computation reduce expressions?
It finds the first expression that has no nested expressions.
It uses that expression to interact with the context.
The context produces more data or another expression.



What if I use period like a lambda abstraction?
	x . x + x
How do I talk about functions in a generic way?
when i talk about the type of a function, i don't talk about the symbol used as a parameter.




how do pointers work?
they arent typed.

x . x + x



	x <- 1
	y <- x @
	z <- y @
How do pointers work?
Are they typed?
Yes.



So what's my fucking notation now???

Assignment: _ ; _
Binding: _ : _
Parameterization: _ . _
Application: _ _ 
Interaction: _ _

How does juxtaposition work?
Can you juxtapose in either direction?

	f : Function,
	c : Collection,
	x c f,
	x f c,
	f x c,
	f c x,
	c x f,
	c f x

so you can actually juxtapose in any direction.
What about currying?
	
	g : (Function *): Function,
	g c f x x = g(c f x)(x),
	g c f x c = g((c (f x))c)
what is the algorithm here for application?
you have a sequence of juxtaposed terms.
how are they reduced?
You have an something that can be applied and something that can't, then there's several cases
- a a	the first is applied on the second
- a c	the first is applied on the second
- c a	the second is applied on the first
- c c	none are applied, this is two separate expressions.
So aren't infix operators just
{* | x . {* | y . op(x y)}}



I don't know if I like my syntax.
The symbols and names for things aren't that great.
How do I do better?

Constructors are obvious
Types:		[ ... ]
Collections:	{ ... }
Compute:	( ... )

Type Binding is the colon	:
Clobber is the semicolon	;
They're both forms of binding.

I also need shortcuts to refer to
Type of Types:		[]
Type of Collections:	{}
Type of Functions:	()
Type of Expressions:	()
Type of Symbols:	Symbol
Type of Anything:	*
Type of Nothing:	_
Is there any point where I would need an empty version of any of these?
No, in most cases where I'm talking about empty constructors, I'm talking about the generalized types of those.

What about destructuring collections?
You can select by type or by position.
Select by type:		_ / _
Select by index:	_ \ _
Might be a complaint that these operators aren't clear.
What else can be used for selecting?
Underscore, colon, semicolon, period...
I think the forward and backward slash are fine for this.

Should the function constructor be an arrow or a dot?
x . x + x
x -> x + x
An arrow. It's more clear what's going on.
If that's the constructor, how do I write a function type?
It's different than a function constructor because I'm not talking about which symbols I'm binding as parameters.
It would be more like 
"Something applied to something computes to something"
Is a function the same as an expression?
Yes actually.
So then a function of A to B would be 
	(Function A : B)



What's minimal ASC?
no types
everything is a Value
You have arithmetic
the ability to clobber
equality comparison
no variable names, everything is from the context.



Fixed context elements:
% / Expression
% / 


How to identify what is an expression in the context and what is a normal binding?
Make an expression type.
({'b} | 1) : Expression



A property where
(x -> x : 1) *  = 1



What happens when I clobber a surface?
% ; % + 1 | 1, % 1 ; 2
You can't actually clobber a surface.
You can replace it with another surface.



If you need a context then you need to forcibly enter a new context.
How do you do that?

%\#% <- Expression : 
	{'a} | % <- 	{
			% 
			count : Value 
			(Expression : {'b} | count <- count + 1)
			(Expression : {'c} | % <- %)
      			}



What's the minimal syntax?
	{ ... }
	( ... )
	_ <- _
	%
	_ = _
	_ /= _
	_ < _
	_ > _
	@ _
	^ _



how does construction work?
You claim a portion of storage not less than the storage requirements of the constructed object.
The storage portion is treated as a place and is given a unique place value.



how are collections made?
Can elements in a collection be in separate locations?
Yes. 
The collection is an object and the objects "in" the collection are separate.
Does this mean that the entities in the collection can be in non-adjacent locations?
Yes.
How to enforce something has an adjacent location?
What information does a collection actually contain then?
The location of each of its elements.
Is there any case where type information should be dynamically included?
Type information is stored separately from the program.
So what happens if I query the type of something?
	^ x
The type information is constant.
What is type information?
The program that results in the type.
So if 
	x : T
then
	^ x = T
you're not actually querying the type of the binding.
You're querying the type of the entity that the binding evaluates to.
So 
	^ [a b c] = Type
	^ (a : [a b c]) = [a b c]
	^ 1 : [1] = [1]
How are types held in a context?
Say that you make a new type. 
How is it incorporated with other types?



The type system is not affected by context?
Or is it?
If I have 
	a = Type, b = Type, c = Type,
	x : [a b] = b,
	y : [a b c] = b,
	^ x, ^ y
the type needs to be bound in the context.
if the type is released from a context then you can't use it.
Also how about enums?
	T = [a:Type b:Type c:Type]
what does an unbound symbol in a type mean?
That it's a value of that type.



how does each expression handle unbound symbols?
1	(a)
2	[a]
3	{a}
4	a = 'e
5	a : t

1: returns a semantic error that "a" is not computable
2: binds 'a as a value to the type
3: returns a semantic error that "a" is not computable
4: binds "a" to 'e
5: binds "a" to t
Are these computed?
Yes, compute dispatches a program which decides how to bind the unbound symbols.



a collection is a separate entity from its elements.
a collection and each of its elements each have unique locations.
what about data that's adjacent?
use a value type for that.
you have default values and you can create new compound values from that.



what about operator precedence in arithmetic?
	Sum : Number
	Product : Number
	Exponent : Number
	% <- % + {}



There's a collision between how a function is constructed and how it's typed.
A function constructor takes a parameter name as a symbol, but it does not allow for an input type to be specified with the parameter.
The purpose of a function is twofold. 
It creates a symbolic substitution of a variable with an input parameter.
It encloses an expression in a context which is evaluated later.
Thus a function is structurally typed according to the input-output pair, and it exists as a syntactic form.
Using arrow notation, how should a function be given a parameter and a type?
        f : T -> t
        f = x -> y
So the function constructor has the form
        {Symbol '-> Expression}
When should the function constructor have the form
        {Expression '-> Expression}
that's simple, it would be
        f : (T) -> t
        f = x -> y
Because the type of () always yields an expression.



Data description.
The environment assumes the presence of two capabilities:
The ability to hold data while a transformation is being applied.
The ability to store data while it is not being held.
A minimum of two data formats are required, a format for transformations and a 
format for storage.
The storage format is called a Byte.
The transformation format is called a Word.



What are my terms?
A collection can include a surface as an element.
A surface maps some entity to another entity, the reaction.
A program may interact with a Collection by providing it with an entity matching the type of entity in the surface.
The collection will then produce the reaction entity.



How do I create expressions?
By backtick and parens.
`(1 '+ 1)
It's the same as asserting that you're creating an expression
(1 '+ 1):Expression
So how would you do a macro?
	% <- % + `{'o T} | t, o T
=
	`(`(`(%) '<- `(% '+ `(`({'o T}:Expression) '| `(t))) ', `('o T))
=
	`(
		`(
			`(%)
			'<-
			`(
				%
				'+
				`(
					`(
						{'o T} : Expression
					)
					'|
					`(t)
				)
			)
		)
		',
		`(
			'o
			T
		)
	)
Here's the problem, this is a nested expression which introduces a macro to the context and then uses that macro.
How is this possible?
Read determines the innermost expression, then computes it.
So this means that Read and Compute must be interleaved.
Or this means that Compute is the same function as Read.




A hard limit of the universe is that if I have a compound expression
	e1, e2
where the well-formedness of "e2" depends on computing "e1",
then I cannot verify that "e2" is well-formed without first computing "e1".



If my language is dynamically typed, can I stil check expressions?
Say I have two functions,
	f : (a) -> b
	g : (d) -> c
and I combine them,
	(g f a)
I get a type error when the reader determines 
	(f a)
without evaluating the function.



the type of an expression is known ahead of time because it's an interaction and interactions are typed just like functions are.



what if a function includes new syntax?
	f = x -> (% <- % + {'a x} | n -> n\1, a 1)



how are types taken into account?



evaluation model is stratified
you have a compound expression, 
	e1, e2
and reading e2 depends on evaluating e1, so then you would compute e1 explicitly
	compute e1, e2



so I have a context, %
it's a collection containing the grammar, the expression being computed, and any context-bounded data.
	% = {g = {}, e, d_0, d_1, d_2, ..., d_n}
I can change the grammar, the expression being evaluated, or any of the data.
I want specific behavior, when I write
	% <- e
I want the context to be replaced entirely with one evaluating "e".
when I write
	% <- {}
I want the entire context to be replaced with the new collection.
what form does the context have?
the address of the external context.
so I'm replacing part of the context.
what does the context contain?
- the address of the external context
- the collection of grammars
- the expression being evaluated
- the collection of data
so there's four things.
how do I expression these four things?
just specific indicies in %?
or do I use names?
I should use a combination of names and types

%/Expression yields the current expression
%/% yields the external context
%/Collection yields all the bindings
So there's a triple of a context, an expression structure, and a collection of bindings.



what higher order operators should I use with collections?
i have a filter operation already
	c / t
I want an operation that does something for each element.
that's just iteration.
but is it built in?
no just iterate or provide a macro.



so how do I iterate?



What's the notation for creating an expression.
It's just ( ... )
What if I want to quote a constructor?
("{" 'a 'b 'c "})
That's how you quote a constructor.



Say I have two collections
A : Collection, B : Collection
how would I make them contain each other?
A = {B}, B = {A}
This works because the collection is a separate structure than the entities. 
Rather than an infinite nested chain, it's a cycle.



collections are just vectors of pointers.
so you can easily filter append and delete from them.
How do you do that?
addition and subtraction
can you add one at a time?
no you can add multiple
{a} + {b} = {a b}
{a b} - {a} = {b}
{a} + {{b}} = {a {b}}



how do I interleave computation?
Like with my "dependent" contexts thing.
how do I say `e1` before reading `e2`?
	(e1), e2
	Compute e1, e2
how do I quote an expression?
	x <- ` 1 + 1
just the backquote
that makes an unevaluated expression
then you can eval it a bunch of times
	x <- ` 1 + 1, (x) + (x)
or you can do a tagbody
	n = 10, (loop <- ` ?(n > 0) n <- n - 1, (loop) n)



So how are Read and Compute interleaved?
Every sub-expression is treated as an individual program.
Contexts are built up as each program is computed.
Lets take a very confusing program.


	(x <- ` %/Collection <- %/Collection + {")"} | 1)
this modifies the context so that the closing paren evaluates to the number 1 rather than bounding an expression.
but it's quoted so it's not evaluated right away.
It's evaluated after it's bound.
so then the expression is equivalent to 
	(x) 1
So it depends on how the expression is read in and when computation is dispatched on a program representation.
What I have right now is that Read identifies an expression form and 



What is the language hidden in the language?
Function application.
Surface interactions.
Flexible left-or-right juxtaposition.
Currying.
Collections.
Types.
The context model.
Addition and Subtraction on everything.



Do I need to allow reader macros?
Shouldn't there be some kind of reserved characters?
Sure. 
If you want crazy synax, make your own parser.
You can always hand strings to stuff.
So I should be able to reserve some characters and still allow for macros and stuff.
Or I should allow for anything.
I think I can allow for anything.




How to do contexts?
Say I have syntax
	%/Collection <- {{'a t} | T . {'b} | t .}
now how do I do contexts for the expression "a b"
The reader reads in "a" and determines the expression {'a t}
Another expression follows "a" so it constructs
	(a (%))
and reads some more until it determines {'b}
then it has
	(a (b))
which turns into 
	(a t)
which turns into
	(T)
so now i've learned two things,
having a complete program model requires you to compute the program.
A compiled program computes until it reaches a program model with only default syntax.



I do want my code to be self modifying or at least reflective which should work fine since i have homoiconicity.
I also want to do it without parentheses.
in scheme you have 
	(define x 1)
	(lambda (x) x)
and 
	(define (f x) x)
in ASC you have
	x : 1
	x -> x
and 
	f = x -> x
which are structured as 
	('x ': 1)
	('x '-> 'x)
and
	('f '= ('x '-> 'x))

I want a specific constructor for an expression so that it can be typed differently than a collection.
What does that look like?
Just type the thing as an expression.
It doesn't help with nested expressions though.
So multiple things in parens are expressions
Multiple things in curly brackets are collections

` {'a 'b 'c} '- 'a
({'a 'b 'c} '- 'a)
Does this mean complexity, or I just have two separate ways to create the same thing?
I just have two separate ways.


This language is getting complex.
Or is it?



How can I quote an expression that defines its own custom syntax?
I add delimiters in.
` (% <- % + ('a x) | e -> e\2, a 1)
But how does it get read in if I don't know the form of the expression.
Or what case would exist where I want to define new syntax in the middle of the program?



I have a constructor for functions which are just dealing with contexts.
I have a constructor for collections which reduce to sparse vectors.
I have a constructor for types which reduces to collections of unique values.
Therefore I should have a constructor for syntax.



The problem is that my programs are stringly typed. 
You need to read them and compute as you go.
That's slow and expensive, but highly expressive.
I want the structure to be explicit from the types rather than from punctuation.
What do I actually want from my syntax?
I want the ability to parse ANY grammar.
This means I need to have an unrestricted grammar.
In my langauge I have an expression which is a map and is treated as a production rule.
	('a b) | c



Maybe I'm overthinking.
Say I have some values,
	a : [], b : [], c : []
Make a grammar...
	% <- {('f a) | b . ('g b) | c}
Make an expression...
	g f a
But this is all one program
	a : [], b : [], c : [],
	% <- %+ {('f a) | b . ('g b) | c},
	g f a.



How can the context have the current computation if the current computation hasn't been read in yet?
How does this expression work?
	dotimes	= n -> e ->
	      (k <- ` ? n > 1 
	      		(e), n <- n - 1, % / Expression <- k
			(e))
Lisp-ified
	(bind dotimes (lambda n (lambda e 
		(clobber k (quote (if (greater n 1) 
			((eval e), (clobber n (- n 1)), (clobber (in this Expression) k))
			(eval e))))))
remove parens
	bind dotimes lambda n lambda e
		clobber k quote if greater n 1
			eval e, clobber n - n 1 clobber in this Expression k
			eval e
The structure is still almost clear since every word is either a function or a parameter.
My language has infix operators and all sorts of crap so it's harder.
Read "harder" as more ambiguous.



how does reading work?
Say I have an expression,
	"x + y"
and it's program model is
	(('x) '+ ('y))
It's computed as
	(compute(((compute ('x)) '+ (compute('y)))
How is read interleaved into this?
Not sure since Read has to determine the structure.
How to determine when Read should read more things?
Read has to go by expression.
Or the context does not contain expression bindings.
That doesn't make sense because you can bind tokens in a context.
There's the structural part. 
Every token is delimited by space.
Expressions have no set delimiter unless you're lisp and you use parentheses.
Expressions are not ambiguous though, you just need to infer the boundaries.




So the read function accepts a string describing a program model and produces the program model.
It determines an expression by matching symbols to declared patterns.
So how then do I make the switch between undelimited expressions and delimited expressions?
A sub-lisp.
Parens form collections without creating a new context.
One expression for each pair of parens.
Constructors and constants can skip parens.
I can also construct this by the expression quotation.
I get the structure automatically.
So then I can add parens as I want for visual clarity or to remove any possible ambiguity in application order.



What's my syntax then?
Constructors...
	Collection	{ ... }
	Type		[ ... ]
	Expression	( ... )
	Function	_ -> _
	Number		0123456789
	Byte		Byte
	Word		Value
	Composite	_ ; _

Expressions...
	Add		_ + _
	Sub		_ - _
	Mul		_ * _
	Div		_ / _
	Mod		_ | _
	And		_ /\ _
	Or		_ \/ _
	Not		  - _
	Less		_ < _
	Greater		_ > _
	Equal		_ = _
	Inequal		_ /= _
	Conditional	? _ _ _
	Application	_ _
	Interaction	_ _
	Type of		^ _
	Address of	@ _
	At address	@ _
	Size		## _
	Cardinality	# _
	Type Select	_ / _
	Index Select	_ \ _
	

Constants...
	This		&
	Any		*
	Nul		_




Aren't interaction and application the same thing??
Yeah.
A function is constructed as
	{Symbol, Expression}
When you apply the function, it's
	* {Symbol, Expression, * | p -> %/Symbol <- p, (%/Expression)}



How to quote an expression that defines new syntax?
Parentheses.
How to bind an expression?
Can I just create an expression and then bind it?
	('if p:Boolean 'then m:Expression 'else n:Expression) = ? p (m) (n)
Or do I have to do
	% <- % + ('if Boolean 'then Expression 'else Expression) | 
		e -> ? e\1 (e\3) (e\5)
In lisp, you can do something like macrolet where you define a macro which is used in a temporary context.
In my langauge, you can define new syntax for any context.
The problem is how you can quote an expression that modifies the part of the context that Read uses.
The answer is to just use lisp forms. 
If you want to quote an expression, you simply build the program model.
You don't need quoting because you just go straight to making the data structure.



How should I set the expression in the context.
It should be an interaction.
	& x , "sets the expression to whatever 'x' is"
Here's the problem though, what happens if a function needs to return an unevaluated expression?
If you try to say that the final result is an expression, then that expression just gets computed.
	"exit a context", & <- d
	"set a new current expression", & e
	"set a new binding", & <- & + b



A surface shouldn't need a function to work.
There should be a parameterization method that is not a function.
Parameterization is syntactic though.
Binding of a symbol is deferred until computation.
What about currying though.
How to add two numbers by currying collections?
	add = {Number | { Number | x + y}}
So can it just be that the first symbol is bound to the argument?
Is there any problem to that?
Nope, the algorithm for resolving symbols can just keep a list of everything that needs to be bound and then bind them as it discovers parameters.



I don't like that the program model isn't static.
I can't have a program model that must be partially evaluated to make sense.
The structure of it must be in the syntax.
With lisp, that's parentheses.
I have no structured syntax.
You have to determine subexpressions from punctuation and type information.



The decision is this: a program is the composition of some computations which are repeated in the same way for each time the program is run. 
Some of these computations are only required to be run once for all possible repetitions of the program. Maybe to configure the initial state of the program, or to abbreviate repetition in the program model. 
How do I decide which computations are run exactly once for a program?
I would place the results of these computations as constant values.
How do I make constant values? I create types.
Compare
	x = 1
	y : 1
here "x" is bound every time the program is run, but "y" is only bound once.
How about complex programs?
	z : [f x]
here "z" is bound to the result of some sub-program which is computed only once ever to produce the final program.
Is this the same issue as syntax or a separate issue?
Possibly the same.
It's a tiny bit insane that a program must be read and executed all at the same time.
It's more than a tiny bit insane that reading one part of the program is dependent on computing a previous part of the program.
I also can't switch between this and static checking of a program.
Or can I?
Technically the program I write can be one that builds a program model, which is checked as it goes, representing the final program.
So if I want a complete statically checked program then I build a program that checks everything before it completes.
So then this means I start with a completely dynamic program and slowly build up static checking.



Should an assembler and other stuff be part of the implementation or part of the standard library?
It should be part of the implementation.
The assembler should also take some kind of minimum subset.
An "untyped" langauge where everything is just Words and Bytes.
What does that language include?
	Collections 	{}
	Clobber		_ <- _
	Equality	=
	


A whole program is read in and a complete model is constructed before it's computed.
This means that a program cannot define new syntax and then use it.
This sucks and isn't necessary.
It's better to have a static verifyer as part of the library.
Use meta to its fullest.
Enforce portions of a program which are verified as part of compilation.
This is super duper meta.
How does new syntax fit into this?
Think of the progression of 
"I am going to"
"Im going to"
"Im gonna"
"Imma"
Abbreviation for commonly repeated things in a domain is useful.
And 20% of the time you can't just abbreviate using built in function notation.
Some languages like smalltalk or forth are lose enough where it doesn't matter.
Here's a compromise, Read and Compute use a copy of the syntax that's defined when they were called.
That copy is internal to their state and can't be modified.
Because variable binding and expression binding are different mechanisms.
Variable binding is taking a symbol constant and interacting with the context
	x
	& 'x
Expression binding is algorithmically replacing part of the program model with a different part.
Variable binding is resolved as a context access.
Expression binding requires the compute function to fullfill.



What types of errors can result from not writing a correct program?
-	"program is mal-formed"
-	"contradicting bindings"
-	"no matching definition"
- 	"ambiguous expression"


How is an expression typed?
An expression is either a constructor, in which case it's replaced with data, 
	('k) | "data"
or it has some "holes" where sub-expressions are placed
	('k t) | 'e -> e\1
A hole is signified by a type.
Punctuation is signified by a value.
An expression returns a type which is either some data or another expression.
Is the type of something that returns an expression, an expression?
Not when Read is verifying the program model.
Expressions are assumed to be computed so the type is never an Expression unless
you are computing something that constructs a program model.
So then the type of an expression is what results from computing it.
How do you determine the type of an expression?
By observing the types of the sub-expressions.
Sometimes the type of a computed expression may depend on the type of the sub-expression.



The type of an expression is the type of the element produced when it is computed.
In the case of an expression comprised of nested expressions, the type produced 
by computation may depend on the result of computing one or more of the sub-expressions.



Should I provide functionality as C or as bytecode?
If I provide it as bytecode then you can port it anywhere.
I'm thinking about it wrong though.
All I'm coding in C is the read, compile, and display functions.
Anything else is compiled straight to assembly.
There's a lot of type stuff which I would like to be statically checked before computation.
But there's also a bunch of dynamic stuff which is useful to have.
What's a compromise between each.
Expressions are computed as they are encountered.



Binding can associate symbols with entities or entire expressions with entities.
Binding requires unification.
The goal of Unification is to find for each unbound variable a type with the least number of values.
I would like to bind both variables and expressions.
I would bind a variable by 
	x = 1
assuming x is unbound.
I would bind an expression by
	('if Expression 'then Expression 'else Expression) = ? Expression (Expression) (Expression)
	('loop [('for Number) ('while Boolean)] Expression) = 


What does labelling an expression look like?
	do : Number -> Function -> * =
	'n -> 'f -> (
		( l : `	? n > 1 
			(f), n <- n - 1, (l) 
			(f) )
as a one-liner
	do : Number -> Function -> * = 
	'n -> 'f -> (l : ` ? n > 1 (f), n <- n - 1, (l) (f))

Is this the same as goto?
No.
Goto is if you set the context to an expression.

	do : Number -> FUnction -> Number =
	'n -> 'f -> 
			& l : ` ? 
				n > 1 
				(f), 'n <- n - 1, (& l) 
				(& f)

Both arrows produce special behavior with symbol constants.
The function constructor takes a symbol constant to create a parameterized expression.
The clobber constructor will create or update a binding when given a symbol constant.




How to bind expressions?
An expression is a collection subtype consisting of symbol constants, strings, values, and types.
It's formed using parentheses as
	('a b "c")
But how to bind an expression to some semantics?
The easiest way is to use a function.
	('a b "c") -> ...
But then how do you destructure the parts of the expression?
Do you use a static placeholder?
That prevents currying.
You need a way to bind something to parameterize the expression.
Originally, I combined surface and function notations so that an expression was defined as 
	('a b "c") | 'd -> ...
where the expression was bound to the symbol used as the parameter.



What does the string constructor look like?
	("\"") | _ -> 'str <- {},
		& 'r <- `
			(Read : Char) {
				"\"" | & <- str .
				"\\" | 'str <- str + (Read : Char) .
				Character | 'c -> 'str <- str + c .
			}, 
			(& r) .


What's the deal with commas and periods?
If I'm defining a function, I want
	f = 'x -> a, b, c .
But if I'm defining a function inside a block, I want
	block = (
		f = 'x -> a, b . ,
		f k
	)
a period and then a comma works.
	a , b . , c
is the same as 
	((a , b) , c)

What if I only used parentheses?
How would that look?
Would that even be useful?
I am so tempted to give up and use parentheses instead of inferring the structure.



So I have a number type which can represent complex numbers.
The types are as follows...
	Natural : [], Negative : [], Fraction : [], Irrational : [], Imaginary : [], 
	Integer : [Natural Negative],
	Rational : [Integer Fraction],
	Real : [Rational Irrational],
	Complex : [Real Imaginary],
	Number : 
		[
			Natural
			Negative
			Fraction
			Irrational
			Imaginary
			Integer
			Rational
			Real
			Complex
		]
The first row of value types are default types where the resources required to represent those types are different.
This is not a good idea because it's not extensible. 
The hierarchy stops at the complex numbers and does not admit extensions to any of the types.
Better to use primitives.
At most I should provide Integers and anything beyond that should compose from some kind of ordinal numerical abstractions.
So I start with
	Natural : [], Negative : [], Integer : [Natural Negative],
	Number : [Natural Negative Integer].
This should work because addition, subtraction, multiplication, and division across these whole numbers works properly.
Anything beyond this should require type abstractions rather than being default.



What if I used parentheses instead?
How would it look?
	
	"Bubble Sort",
	BS : List -> List = 
		'l ->
			'n <- 1, 
			('s <- `
				? (l \ n) > l \ (n - 1)
					swap (l n n - 1),
					(s) .
					'n <- n + 1 ,
					(s) .)

vs a delimited expression form

	[ "Bubble sort,
	[[BS : [List -> List]] = 
		['l -> [
			['n <- 1] ,
			[compute ['s <- [? [[l \ n] < [l \ [n - 1]]]
				[[swap [l n [n - 1]]] ,	
				['n <- 0]
				[compute s]]
				[['n <- [n + 1] ,
				[compute s]]]]]]]

The one without delimited expressions is objectively better. 
You can read it easier. 
There's no huge clump of parens at the end of the top level expression.
Parens are used to delimite sub-expressions where necessary.
If you can use regex, then you don't need parens.
Regex is not unrestricted though because you can set context.
That's fine, you can set context in ASC too.



How is stuff stored?
I need to decide because compound data is part of the language.
All the more complex constructs must have a cannonical representation as bytes.
The trick is that all this stuff can have any format it wants because the 
default operations for them ase already supplied.



How is stuff represented in memory.
Each thing has a representation as a compound data type.
Data is one of 
Byte, Word, Reference.

Symbol is a sequence of bytes.
Collection is sequence of References.
Function is a pair of a Symbol and an Expression.
Number is a sequence of bytes.
What is a type?
A collection of unique values.
What about a quantified type?
	"A normal type is ", [1 2 3],
	"but a quantified type is ", [x : T, f x]
	"where the values may not be finite."

So the reader has to infer the structure of the program model from punctuation.
This is easier than you would think because the punctuation usually makes sense.
Also the read direction is always from left to right.
Nope, I'd rather do a Lisp.
The point is that grammar can be whatever you want for any given expression because 
individual expressions are always delimited.
There are things that count as expression though.
() [] {} "" '
Nobody's going to care that much about the syntax as long as the language does cool stuff.
What's my expression delimiter?
<> () [] {}?
Parens are a traditional delimiter, but my language is not a lisp. 
It can be emulated as a lisp, but it's not.
Take a simple program...
	((f : (T -> T)) = ((x) -> x))
	<<f : <T -> T>> = <<x> -> x>>
	[[f : [T -> T]] = [[x] -> x]]
	{{f : {T -> T}} = {{x} -> x}}
Definitely parentheses are the way to go.
